<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Web of Things (WoT) Scripting API</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class='remove'>
      // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
      var respecConfig = {
        specStatus: "ED",
        shortName: "wot-scripting-api",
        copyrightStart:       2017,
        noLegacyStyle:        true,
        publishDate:          "",
        previousPublishDate:  "",
        previousMaturity:     "",
        edDraftURI:           "https://w3c.github.io/wot-scripting-api/",
        crEnd:                "",
        inlineCSS:            true,
        noIDLIn:              true,
        format:               'markdown',
        editors: [
          { name: "Zoltan Kis", company: "Intel", companyURL: "https://www.intel.com/" },
          { name: "Kazuaki Nimura", company: "Fujitsu Ltd.", companyURL: "https://www.fujitsu.com/" },
          { name: "Daniel Peintner", company: "Siemens AG", companyURL: "https://www.siemens.com/" },
          { name: "Johannes Hund", note: "Former Editor, when at Siemens AG" },
        ],
        wg:           "Web of Things Working Group",
        wgURI:        "https://www.w3.org/WoT/WG/",
        wgPublicList: "public-wot-wg",
        issueBase: "https://www.github.com/w3c/wot-scripting-api/issues/",
        githubAPI: "https://api.github.com/repos/w3c/wot-scripting-api",
        otherLinks: [
          {
            key: "Contributors",
            data: [
                {
                  value: "In the GitHub repository",
                  href: "https://github.com/w3c/wot-scripting-api/graphs/contributors"
                }
            ]
          },
          {
            key: "Repository",
            data: [{
                  value: "We are on GitHub",
                  href: "https://github.com/w3c/wot-scripting-api"
              }, {
                  value: "File a bug",
                  href: "https://github.com/w3c/wot-scripting-api/issues"
              },
            ]
          },
        ],
        localBiblio: {
          "WOT-ARCHITECTURE" : {
            href:"https://w3c.github.io/wot-architecture/",
            title: "Web of Things Architecture",
            publisher: "W3C",
            date: "20 August 2017"
          },
          "WOT-TD" : {
            href:"https://w3c.github.io/wot-thing-description/",
            title: "WoT Thing Description ",
            publisher: "W3C",
            date: "20 August 2017"
          },
          "WOT-PROTOCOL-BINDINGS" : {
            href:"https://w3c.github.io/wot-binding-templates/",
            title: "Web of Things Protocol Binding Templates",
            publisher: "W3C",
            date: "20 August 2017"
          },
          "WOT-PRACTICES": {
            href:"http://w3c.github.io/wot/current-practices/wot-practices.html",
            title: "Web of Things Current Practices",
            publisher: "W3C",
            date: "6 February 2017"
          },
          "TYPESCRIPT": {
            href:"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md",
            title: "TypeScript Language Specification",
            publisher: "Microsoft",
            date: "1 October 2012"
          },
          "WEBAPPSEC": {
            href:"https://w3c.github.io/webappsec/specs/powerfulfeatures",
            title: "Secure Contexts",
            publisher: "W3C",
            date: "17 July 2015"
          },
        },
      };
    </script>
  </head>
  <body>

  <section id="abstract">
    <p>
      The overall <a>Web of Things</a> (WoT) concepts are described in the [WoT Architecture](https://w3c.github.io/wot-architecture/) document. The Web of Things is made of entities (<a>Thing</a>s) that can describe their capabilities in a machine-interpretable format, the <a>Thing Description</a> (TD) and expose these capabilities through the <a>WoT Interface</a>, that is, network interactions modeled as <a>Properties</a> for reading and writing values, <a>Action</a>s to execute remote procedures with or without return values and <a>Event</a>s for signaling notifications.
    </p>
    <p>
      This specification describes a programming interface representing the <a>WoT Interface</a> that allows scripts run on a <a>Thing</a> to discover and consume (retrieve) other <a>Thing Description</a>s and to expose <a>Things</a> characterized by <a> WoT Interactions</a> specified by a script.
    </p>
    <p>
      Scripting is an optional "convenience" building block in WoT and it is typically used in gateways that are able to run a <a>WoT Runtime</a> and <a href="https://github.com/w3c/wot-scripting-api/tree/master/applications/script-manager">script management</a>, providing a convenient way to extend WoT support to new types of endpoints and implement WoT applications like <a href="https://github.com/w3c/wot-scripting-api/tree/master/applications/thing-directory">Thing Directory</a>.
    </p>
  </section>

  <section id="sotd">
    <p>
      Implementers need to be aware that this specification is considered unstable. Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation phase should subscribe to the [repository](https://github.com/w3c/wot-scripting-api) and take part in the discussions.
    </p>
    <p class="ednote" title="The W3C WoT WG is asking for feedback">
      Please contribute to this draft using the <a href="https://github.com/w3c/wot-scripting-api/issues">GitHub Issue</a> feature of the <a href="https://github.com/w3c/wot-scripting-api/">WoT Scripting API</a> repository.
      For feedback on security and privacy considerations, please use the <a href="https://github.com/w3c/wot-security/issues">WoT Security and Privacy</a> Issues.
    </p>
  </section>

  <section id="introduction"> <h2>Introduction</h2>
    <p>
      WoT provides layered interoperability based on how <a>Thing</a>s are modeled: as being "consumed" and "exposed".
    </p>
    <p>
      By <a>consuming a TD</a>, a client <a>Thing</a> creates a runtime resource model that allows accessing the <a>Properties</a>, <a>Actions</a> and <a>Events</a> exposed by the  server <a>Thing</a> exposed on a remote device.
    </p>
    <p>
      Exposing a <a>Thing</a> requires defining a <a>Thing Description</a> (TD) and instantiating a software stack to serve requests for accessing the exposed <a>Properties</a>, <a>Actions</a> and <a>Events</a>. This specification describes how to expose and consume <a>Thing</a>s by a script.
    </p>
    <p class="note">
      Typically scripts are meant to be used on devices able to provide resources (with a <a>WoT interface</a>) for managing (installing, updating, running) scripts, such as bridges or gateways that expose and control simpler devices as WoT <a>Thing</a>s.
    </p>
    <p class="note">
      This specification does not make assumptions on how the <a>WoT Runtime</a> handles and runs scripts, including single or multiple tenancy, script deployment and lifecycle management. The API already supports the generic mechanisms that make it possible to implement script management, for instance by exposing a manager <a>Thing</a> whose <a>Actions</a> (action handlers) implement script lifecycle management operations.
    </p>
    <p>
      For an introduction on how scripts could be used in <a>Web of Things</a>, check the [Primer](https://w3c.github.io/wot-scripting-api/primer) document. For some background on API design decisions check the [Rationale](https://w3c.github.io/wot-scripting-api/rationale) document.
    </p>
  </section>

  <section class="informative"> <h3>Use Cases</h3>
    <p>
      The following scripting use cases are supported in this specification:
    </p>
    <section><h4>Discovery</h4>
    <ul>
      <li>Discover all <a>Thing</a>s in the WoT network by sending a broadcast request.</li>
      <li>Discover <a>Thing</a>s running in the local <a>WoT Runtime</a>.</li>
      <li>Discover nearby <a>Thing</a>s, for instance connected by NFC or Bluetooth.</li>
      <li>Discover <a>Thing</a>s by sending a discovery request to a given registry.</li>
      <li>Discover <a>Thing</a>s by filters defined on <a>Thing Description</a>s</li>
      <li>Discover <a>Thing</a>s by semantic queries.</li>
      <li>Stop or suppress an ongoing discovery process.</li>
      <li>
          Optionally specify a timeout to the discovery process after which it is stopped/suppressed.
      </li>
    </ul>
    </section>
    <section><h4>Consuming a Thing</h4>
    <ul>
      <li>
        Fetch a <a>Thing Description</a> of a <a>Thing</a> given its URL.
      </li>
      <li>
        <a>Consume a TD</a> of a <a>Thing</a>, including parsing the <a>TD</a> and generating the protocol bindings in order to access lower level functionality.
      </li>
      <li>On a consumed <a>Thing</a>,
        <ul>
          <li>Read the value of a <a>Property</a> or set of properties.</li>
          <li>Set the value of a <a>Property</a> or a set of properties.</li>
          <li>Observe value changes of a <a>Property</a>.</li>
          <li>Invoke an <a>Action</a>.</li>
          <li>Observe <a>Events</a> emitted by the <a>Thing</a>.</li>
          <li>Observe changes to the <a>Thing Description</a> of the <a>Thing</a>.</li>
          <li>Get the <a>Thing Description</a>.</li>
          <li>Get the list of linked resources based on the <a>Thing Description</a>.</li>
        </ul>
      </li>
    </ul>
    </section>
    <section><h4>Exposing a Thing</h4>
    <ul>
      <li>
        Exposing the <a>Thing</a> includes generating the protocol bindings in order to access lower level functionality.
      </li>
      <li>
        Create a local <a>ExposedThing</a> to be exposed, based on a <a>Thing Description</a> provided in string serialized format, or out of a template or an existing <a>ConsumedThing</a> object.</li>
      <li>Add a <a>Property</a> definition to the <a>Thing</a>.</li>
      <li>Add an <a>Action</a> definition to the <a>Thing</a>.</li>
      <li>Add an <a>Event</a> definition to the <a>Thing</a>.</li>
      <li>Attach semantic information to the <a>Thing</a>.</li>
      <li>Attach semantic information to a <a>Property</a>.</li>
      <li>Attach semantic information to an <a>Action</a>.</li>
      <li>Attach semantic information to an <a>Event</a>.</li>
      <li>
        Emit an <a>Event</a>, i.e. notify all listeners subscribed to that <a>Event</a>.
      </li>
      <li>
        Provide notifications for <a>TD</a> changes to clients subscribed to that.
      </li>
      <li>Mark/unmark the Thing to be discoverable.</li>
      <li>Mark/unmark the Thing to be consumable.</li>
      <li>Start the exposed <a>Thing</a> in order to process external requests.</li>
      <li>Stop the exposed <a>Thing</a>.</li>
      <li>Register handlers for external requests:
        <ul>
          <li>to retrieve a <a>Property</a> value;</li>
          <li>to update a <a>Property</a> value;</li>
          <li>
            to run an <a>Action</a>: take the parameters from the request, execute the defined action, and return the result;
          </li>
        </ul>
      </li>
    </ul>
    </section>
  </section>

  <section data-dfn-for="WoT">
    <h2>The <dfn>WoT</dfn> object</h2>
    <p>The WoT object is the API entry point and it is exposed by an implementation of the <a>WoT Runtime</a>. The <dfn>WoT object</dfn> does not expose properties, only methods for discovering, consuming and exposing a <a>Thing</a>.
    </p>
    <p class="note">
       Browser implementations SHOULD use a namespace object such as <code>navigator.wot</code>. <a href="https://nodejs.org/en/">Node.js</a>-like runtimes MAY provide the API object through the <a href="https://nodejs.org/api/modules.html">require()</a> or <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-imports">import</a> mechanism.
    </p>
    <pre class="idl">
      // [SecureContext]
      // [NamespaceObject]
      interface WoT {
        Observable&lt;ThingDescription&gt; discover(optional ThingFilter filter);
        Promise&lt;ThingDescription&gt; fetch(USVString url);
        ConsumedThing consume(ThingDescription td);
        ExposedThing produce(ThingModel model);
        Promise&lt;void&gt; register(USVString directory, ExposedThing thing);
        Promise&lt;void&gt; unregister(USVString directory, ExposedThing thing);
      };
      typedef dictionary ThingTemplate;
      typedef USVString ThingDescription;
      typedef (ThingTemplate or ThingDescription or ConsumedThing) ThingModel;
    </pre>

    <p class="ednote">
      The algorithms for the WoT methods will be specified later, including error handling and security considerations.
    </p>

    <p>
      The <dfn>ThingModel</dfn> type represents either a <a>ThingTemplate</a>, or a <a>ThingDescription</a> or a <a>ConsumedThing</a> object.
    </p>

    <section data-dfn-for="ThingDescription">
    <h3>The <dfn>ThingDescription</dfn> type</h3>
      <p>
        Serialized representation of the <a>Thing Description</a> (a <a>JSON-LD</a> document).
      </p>
      <p class="note">
        In this version of the API, <a>Thing Description</a>s are represented as an opaque <code>USVString</code> that can be transmitted between devices.
      </p>
    </section>

    <section data-dfn-for="ThingTemplate">
      <h3>The <dfn>ThingTemplate</dfn> dictionary</h3>
      <p>
        <a>ThingTemplate</a> is a dictionary that contains properties representing semantic metadata and interactions (<a>Properties</a>, <a>Action</a>s and <a>Event</a>s). It is used for initializing an internal representation of a <a>Thing Description</a> as defined in [[!WOT-TD]], and it is also used in <a>ThingFilter</a>. The set of core properties is defined below. In addition, <a>ThingTemplate</a> may contain other properties as well as defined in the <a>Thing Description</a> from which the <a>Thing</a> object is created.
      </p>
      <ul>
        <li>
          The <dfn>name</dfn> attribute represents the name of the <a>Thing</a> as <code>DOMString</code>. In the <a>Thing Description</a> this attribute is mandatory, but in <a>ThingFilter</a> it is optional.
        </li>
        <li>
          The <dfn>id</dfn> optional attribute represents an application provided hint for the unique identifier of the <a>Thing</a>, typically a URI, IRI, or URN as <code>USVString</code>. Note that this is not the same as the <a>JSON-LD</a> <code>@id</code> attribute. Also note that the <a>WoT Runtime</a> may override this with a different value when exposing the <a>Thing</a>.
        </li>
        <li>
          The <dfn>description</dfn> optional attribute of type <code>DOMString</code> represents a human readable description of the <a>Thing</a>.
        </li>
        <li>
          The <dfn>support</dfn> optional attribute of type <code>DOMString</code> represents human readable information about the <a>TD</a> maintainer.
        </li>
        <li>
          The <strong><em>security</em></strong> optional attribute represents security metadata defined by the <a>SecurityScheme</a> dictionary;
        </li>
        <li>
          The <strong><em>properties</em></strong> optional attribute represents a dictionary with keys that correspond to <a>Property</a> names and values of type <a>PropertyInit</a>.
        </li>
        <li>
          The <strong><em>actions</em></strong> optional attribute represents a dictionary with keys that correspond to <a>Action</a> names and values of type <a>ActionInit</a>.
        </li>
        <li>
          The <strong><em>events</em></strong> optional attribute represents a dictionary with keys that correspond to <a>Event</a> names and values of type <a>EventInit</a>.
        </li>
        <li>
          The <strong><em>links</em></strong> optional attribute represents an array of <a>WebLink</a> objects.
        </li>
        <li>
          The <dfn>@context</dfn> optional attribute represents a semantic context as <code>USVString</code>.
        </li>
        <li>
          The <dfn>@type</dfn> optional attribute represents a semantic type as <code>USVString</code>.
        </li>
        <li>
          Apart from the core properties defined above, others may also be defined on a <a>Thing</a>, for instance <code>"@id"</code>, <code>"gms:COVParams"</code> (with namespace definition), or <code>"iotschema:unit"</code> etc.
        </li>
      </ul>
      <p class="ednote">
        Support for configuration and security metadata will be added later.
      </p>
    </section> <!-- ThingTemplate -->

    <section> <h3> The <dfn>fetch()</dfn> method</h3>
      <p>
        Accepts an <code>url</code> argument of type <code>USVString</code> that represents a URL (e.g. <code>"file://..."</code> or <code>"https://..."</code>) and returns a <code><a>Promise</a></code> that resolves with a <a>ThingDescription</a> (a serialized <a>JSON-LD</a> document of type <code>USVString</code>).
      </p>
    </section>

    <section> <h3> The <dfn>consume()</dfn> method</h3>
      <p>
        Accepts an <code>td</code> argument of type <code><a>ThingDescription</a></code> and returns a <a>ConsumedThing</a> object instantiated based on parsing that description.
      </p>
    </section>

    <section> <h3>The <dfn id="produce-method">produce()</dfn> method</h3>
      <p>
        Accepts a <code>model</code> argument of type <code><a>ThingModel</a></code> and returns an <a>ExposedThing</a> object. An <a>ExposedThing</a> can be created in the following ways:
      </p>
      <ol>
        <li>
          from a <a>ThingTemplate</a>, then adding <a>Properties</a>, <a>Actions</a>, <a>Events</a> and request handlers;
        </li>
        <li>
          from a <a>Thing Description</a> or a <a>ConsumedThing</a> object, then adding request handlers.
        </li>
      </ol>
    </section> <!-- produce() -->

    <section> <h3>The <dfn>register()</dfn> method</h3>
      <p>
        Takes two mandatory arguments:
        <ul>
          <li><code>directory</code> denoting a <a>Thing Directory</a>, and </li>
          <li><code>thing</code> denoting an <a>ExposedThing</a> object.</li>
        </ul>
      </p>
      <p>
        Generate the <a>Thing Description</a> as <var>td</var>, given the <a>Properties</a>, <a>Action</a>s and <a>Event</a>s defined for this <a>ExposedThing</a> object. Then make a request to register <var>td</var> to the given WoT <a>Thing Directory</a>.
      </p>
    </section>

    <section> <h3>The <dfn>unregister()</dfn> method</h3>
      <p>
        Takes two mandatory arguments:
        <ul>
          <li><code>directory</code> denoting a <a>Thing Directory</a>, and </li>
          <li><code>thing</code> denoting an <a>ExposedThing</a> object.</li>
        </ul>
      </p>
      <p>
        Makes a request to unregister the <code>thing</code> from the given WoT <a>Thing Directory</a>.
      </p>
    </section>

    <section> <h3>The <dfn>discover()</dfn> method</h3>
      <p>
        Starts the discovery process that will provide <code><a>ThingDescription</a></code>s that match the optional argument <code><a>ThingFilter</a></code>. When the argument is not provided, uses all supported discovery methods.
        Returns an [<code>Observable</code>](https://github.com/tc39/proposal-observable) object that can be subscribed to and unsubscribed from. Errors are also signaled at the subscription object.
      </p>
      <p class="note">
        Note that canceling a discovery (via invoking <code>unsubscribe()</code>) may not be successful in all cases, for instance when discovery is based on open ended multicast requests. However, once <code>unsubscribe()</code> has been called,  implementations MUST suppress further event handling ( i.e. further discoveries and errors) on the Observable. Also, a discovery error may not mean the end of the discovery process. However, in order to respect Observable semantics (error always terminates processing), implementations MUST close or suppress further event handling on the Observable.
      </p>

      <section data-dfn-for="DiscoveryMethod">
        <h4>The <dfn>DiscoveryMethod</dfn> enumeration</h4>
        <pre class="idl">
          typedef DOMString DiscoveryMethod;
        </pre>
        <p>
          <a>DiscoveryMethod</a> represents the discovery type to be used:
        </p>
        <ul>
          <li><dfn>"any"</dfn> does not provide any restriction</li>
          <li>
            <dfn>"local"</dfn> for discovering <a>Thing</a>s defined in the same device or connected to the device by wired or wireless means.
          </li>
          <li>
            <dfn>"directory"</dfn> for discovery based on a service provided by a <a>Thing Directory</a>.
          </li>
          <li>
            <dfn>"multicast"</dfn> for discovering <a>Thing</a>s in the device's network by using a supported multicast protocol.
          </li>
        </ul>
      </section>

      <section data-dfn-for="ThingFilter">
        <h4>The <dfn>ThingFilter</dfn> dictionary</h4>
        <p>
          The <a>ThingFilter</a> dictionary that represents the constraints for discovering <a>Thing</a>s as key-value pairs.
        </p>
        <pre class="idl">
          dictionary ThingFilter {
            DiscoveryMethod method = "any";
            USVString url;
            USVString query;
            ThingTemplate template;
          };
        </pre>
        <p>
          The <dfn>method</dfn> property represents the discovery type that should be used in the discovery process. The possible values are defined by the <code><a>DiscoveryMethod</a></code> enumeration that MAY be extended by string values defined by solutions (with no guarantee of interoperability).
        </p>
        <p>
          The <dfn>url</dfn> property represents additional information for the discovery method, such as the URL of the target entity serving the discovery request, for instance a <a>Thing Directory</a> (if <code>method</code> is <code>"directory"</code>) or a Thing (otherwise).
        </p>
        <p>
          The <dfn>query</dfn> property represents a query string accepted by the implementation, for instance a SPARQL or JSON query. Support may be implemented locally in the <a>WoT Runtime</a> or remotely as a service in a <a>Thing Directory</a>.
        </p>
        <p>
          The <dfn>template</dfn> property represents a <a>ThingTemplate</a> dictionary used for matching against discovered <a>Thing</a>s.
        </p>
        <p class="ednote">
          Queries and templates are experimental features. Implementations are not required to support them. The template matching algorithm will be defined later, but there are two possibilities: either direct matching (property to property) or serializing the template and matching that against <a>TD</a>s.
        </p>
      </section>
      <p>
        If queries are specified, but not supported, implementations should signal a <code>NotSupportedError</code> on the subscription objects. For security errors (e.g. authentication error) a <code>SecurityError</code> should be signaled. For query validation errors a <code>TypeError</code> should be signaled. For other errors an <code>Error</code> should be signaled.
      </p>
    </section> <!-- Discovery -->

    <section> <h3>Examples</h3>
      <pre class="example" title="Discover Things via directory">
        let discoveryFilter = {
          method: "directory",
          url: "http://directory.wotservice.org"
        };
        let subscription = wot.discover(discoveryFilter).subscribe(
          td => {
            console.log("Found Thing " + td.name);
            // fetch the TD and create a ConsumedThing
            let thing = wot.consume(td);
          },
          error => { console.log("Discovery finished because an error: " + error.message); },
          () => { console.log("Discovery finished successfully");}
        );
        setTimeout( () => {
            subscription.unsubscribe();
            console.log("Discovery timeout");
          },
          5000);
      </pre>
      <pre class="example" title="Discover Things exposed by local hardware">
        let subscription = wot.discover({ method: "local" }).subscribe(
          td => { console.log("Found local Thing " + td.name); },
          error => { console.log("Discovery error: " + error.message); },
          () => { console.log("Discovery finished successfully");}
        );
      </pre>
      <pre class="example" title="Same as above but with different Observable syntax">
        let subscription = wot.discover({ method: "local" }).subscribe({
          td => { console.log("Found local Thing " + td.name); },
          error: err => { console.log("Discovery error: " + err.message); },
          complete: () => { console.log("Discovery finished successfully");}
        });
      </pre>
      <pre class="example" title="Discover Things exposed nearby, via Bluetooth or NFC">
        // Use a proprietary extension of "local" discovery via "constraints"
        let bleSub = wot.discover({
          method: "local",
          constraints: [{ protocol: "BLE-4.2" }, { protocol: "NFC" }]
        }).subscribe(
          td => { console.log("Found nearby Thing " + td.name); },
          error => { console.log("Discovery error: " + error.message); }
        );
      </pre>
      <pre class="example" title="Discover Things exposed in a proprietary way">
        let subscription = wot.discover({
          method: "myOwnMethod", // not standardized
          url: myDirectoryURL,
          // includes non-standard, app-specific property "constraints"
          constraints: [{ account: "XYZ123", key: "..."}]
        }).subscribe(
          td => { console.log("Found Thing " + td.name); },
          error => { console.log("Discovery error: " + error.message); },
          () => { console.log("Discovery finished successfully");}
        );
      </pre>
    </section> <!-- Examples -->
  </section> <!-- WoT API -->

  <section data-dfn-for="ConsumedThing">
    <h2>The <dfn>ConsumedThing</dfn> interface</h2>
    <p>
      The <a>ConsumedThing</a> interface is a client API for sending requests to servers in order to retrieve or update <a>Properties</a>, invoke <a>Actions</a>, and observe <a>Properties</a> and <a>Events</a>.
    </p>
    <pre class="idl">
      interface ConsumedThing {
        readonly attribute maplike&lt;DOMString, ThingProperty&gt; properties;
        readonly attribute maplike&lt;DOMString, ThingAction&gt; actions;
        readonly attribute maplike&lt;DOMString, ThingEvent&gt; events;
        readonly attribute FrozenArray&lt;WebLink&gt; links;
        // getter for ThingTemplate properties
        getter any(DOMString name);
      };
      ConsumedThing implements Observable;  // for TD changes
    </pre>
    <p>
      <code>ConsumedThing</code> represents a local proxy object of the remote <a>Thing</a>.
    </p>
    <p>
      The <dfn>properties</dfn> property represents a dictionary of <a>ThingProperty</a> items.
    </p>
    <p>
      The <dfn>actions</dfn> property represents a dictionary of <a>ThingAction</a> items.
    </p>
    <p>
      The <dfn>events</dfn> property represents a dictionary of <a>ThingEvent</a> items.
    </p>
    <li>
      The <dfn>links</dfn> property represents an array of <a>WebLink</a> objects.
    </li>

    <section>
      <h2>Examples</h2>
      <p>
        Below a <code><a>ConsumedThing</a></code> interface example is given.
      </p>
      <pre class="example" title="Consume a Thing">
        try {
          let subscription = wot.discover({ method: "local" }).subscribe(
            td => {
              let thing = wot.consume(td);
              console.log("Thing " + thing.name + " has been consumed.");
              let subscription = thing.onPropertyChange("temperature")
                .subscribe(function(value) {
                  console.log("Temperature + " has changed to " + value);
                });
              thing.actions["startMeasurement"].run({ units: "Celsius" })
                .then(() => { console.log("Temperature measurement started."); })
                .catch(e => {
                   console.log("Error starting measurement.");
                   subscription.unsubscribe();
                 })
            },
            error => { console.log("Discovery error: " + error.message); },
            () => { console.log("Discovery finished successfully");}
          );
        } catch(error) {
          console.log("Error: " + error.message);
        };
      </pre>
    </section> <!-- Examples -->
  </section> <!-- ConsumedThing -->

  <section data-dfn-for="ExposedThing">
    <h2>The <dfn>ExposedThing</dfn> interface</h2>
    <p>
      The <a>ExposedThing</a> interface is the server API that allows defining request handlers, properties, <a>Actions</a>, and <a>Events</a> to a <a>Thing</a>. It also implements the <a>ConsumedThing</a> interface. An <a>ExposedThing</a> is created by the <a href="#the-produce-method">produce()</a> method.
    </p>
    <pre class="idl">
      ExposedThing implements ConsumedThing;
      interface ExposedThing {
        // setter for ThingTemplate properties
        setter void(DOMString name, any value);
        // define how to expose and run the Thing
        Promise&lt;void&gt; expose();
        Promise&lt;void&gt; destroy();
        Promise&lt;void&gt; emitEvent(DOMString eventName, any payload);
        // define Thing Description modifiers
        ExposedThing addProperty(DOMString name, PropertyInit property);
        ExposedThing removeProperty(DOMString name);
        ExposedThing addAction(DOMString name, ActionInit action);
        ExposedThing removeAction(DOMString name);
        ExposedThing addEvent(DOMString name, EventInit event);
        ExposedThing removeEvent(DOMString name);
        // define request handlers
        ExposedThing setPropertyReadHandler(DOMString name, PropertyReadHandler readHandler);
        ExposedThing setPropertyWriteHandler(DOMString name, PropertyWriteHandler writeHandler);
        ExposedThing setActionHandler(DOMString name, ActionHandler action);
      };
      callback PropertyReadHandler = Promise&lt;any&gt;();
      callback PropertyWriteHandler = Promise&lt;void&gt;(any value);
      callback ActionHandler = Promise&lt;any&gt;(any parameters);
    </pre>

    <section> <h3>The <dfn>expose()</dfn> method</h3>
      <p>
        Start serving external requests for the <a>Thing</a>, so that WoT interactions using <a>Properties</a>, <a>Action</a>s and <a>Event</a>s will be possible.
      </p>
    </section>

    <section> <h3>The <dfn>destroy()</dfn> method</h3>
      <p>
        Stop serving external requests for the <a>Thing</a> and destroy the object. Note that eventual unregistering should be done before invoking this method.
      </p>
    </section>

    <section> <h3>The <dfn>emitEvent()</dfn> method</h3>
      <p>
        Emits an the event initialized with the event name specified by the <code>eventName</code> argument and data specified by the <code>payload</code> argument.
      </p>
    </section>

    <section> <h3>The <dfn>addProperty()</dfn> method</h3>
      <p>
        Adds a <a>Property</a> with name defined by the <var>name</var> argument and qualifiers and initialization value provided by the <var>property</var> argument of type <a>PropertyInit</a>. It updates the <a>Thing Description</a>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
    </section> <!-- addProperty() -->

    <section> <h3>The <dfn>removeProperty()</dfn> method</h3>
      <p>
        Removes the <a>Property</a> specified by the <code>name</code> argument and updates the <a>Thing Description</a>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
    </section>

    <section> <h3>The <dfn>addAction()</dfn> method</h3>
      <p>
        Adds an <a>Action</a> with name defined by the <var>name</var> argument and qualifiers and initialization value provided by the <var>action</var> argument of type <a>ActionInit</a>to the <a>Thing</a> object and updates the <a>Thing Description</a>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
    </section> <!-- addAction -->

    <section> <h3>The <dfn>removeAction()</dfn> method</h3>
      <p>
        Removes the <a>Action</a> specified by the <code>name</code> argument and updates the <a>Thing Description</a>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
    </section>

    <section> <h3>The <dfn>addEvent()</dfn> method</h3>
      <p>
        Adds an event with name defined by the <var>name</var> argument and qualifiers and initialization value provided by the <var>event</var> argument of type <a>EventInit</a>to the <a>Thing</a> object and updates the <a>Thing Description</a>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
    </section>

    <section> <h3>The <dfn>removeEvent()</dfn> method</h3>
      <p>
        Removes the event specified by the <code>name</code> argument and updates the <a>Thing Description</a>. Returns a reference to the same object for supporting chaining.
      </p>
    </section>

    <section data-dfn-for="PropertyReadHandler">
      <h3>The <dfn>PropertyReadHandler</dfn> callback</h3>
      <p>
        A function that returns a Promise and resolves it with the value of the <a>Property</a> matching the <code>name</code> argument to the <code>setPropertyReadHandler</code> function, or rejects with an error if the property is not found or the value cannot be retrieved.
      </p>
    </section>

    <section data-dfn-for="PropertyWriteHandler">
      <h3>The <dfn>PropertyWriteHandler</dfn> callback</h3>
      <p>
        A function called with <code>value</code> as argument that returns a Promise which is resolved when the value of the <a>Property</a> matching the <code>name</code> argument to the <code>setPropertyReadHandler</code> function is updated with <code>value</code>, or rejects with an error if the property is not found or the value cannot be updated.
      </p>
      <p class="ednote">
        Note that this function is invoked by implementations before the property is updated, so the code in this callback function can invoke the <code>readProperty()</code> method to find out the old value of the property, if needed. Therefore the old value is not provided to this method.
      </p>
    </section>

    <section data-dfn-for="ActionHandler">
      <h3>The <dfn>ActionHandler</dfn> callback</h3>
      <p>
        A function called with a <code>parameters</code> dictionary argument assembled by the <a>WoT runtime</a> based on the <a>Thing Description</a> and the external client request. It returns a Promise that rejects with an error or resolves if the action is successful or ongoing (may also resolve with a control object such as an <a>Observable</a> for actions that need progress notifications or that can be canceled).
      </p>
    </section>

    <section> <h3>The <dfn>setPropertyReadHandler()</dfn> method</h3>
      <p>
        Takes <code>name</code> as string argument and <code>readHandler</code> as argument of type <a>PropertyReadHandler</a>. Sets the handler function for reading the specified <a>Property</a> matched by <code>name</code>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
      <p>
         The <code>readHandler</code> callback function will implement reading a <a>Property</a> and SHOULD be called by implementations when a request for reading a <a>Property</a> is received from the underlying platform.
      </p>
      <p>
        There SHOULD be at most one handler for any given <a>Property</a> and newly added handlers replace the old handlers. If no handler is initialized for any given <a>Property</a>, implementations SHOULD implement a default property read handler.
      </p>
    </section>

    <section> <h3>The <dfn>setPropertyWriteHandler()</dfn> method</h3>
      <p>
        Takes <code>name</code> as string argument and <code>writeHandler</code> as argument of type <a>PropertyWriteHandler</a>. Sets the handler function for writing the specified <a>Property</a> matched by <code>name</code>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
      <p>
        There SHOULD be at most one write handler for any given <a>Property</a> and newly added handlers replace the old handlers. If no write handler is initialized for any given <a>Property</a>, implementations SHOULD implement default property update and notifying observers on change.
      </p>
    </section>

    <section> <h3>The <dfn>setActionHandler()</dfn> method</h3>
      <p>
        Takes <code>name</code> as string argument and <code>action</code> as argument of type <a>ActionHandler</a>. Sets the handler function for the specified <a>Action</a> matched by <code>name</code>. Throws on error. Returns a reference to the same object for supporting chaining.
      </p>
      <p>
        If provided, this callback function will implement invoking an <a>Action</a> and SHOULD be called by implementations when a request for invoking a <a>Action</a> is received from the underlying platform. The callback will receive a <code>parameters</code> dictionary argument.
      </p>
      <p>
        There SHOULD be exactly one handler for any given <a>Action</a>. If no handler is initialized for any given <a>Action</a>, implementations SHOULD return error if the action is invoked by any client.
      </p>
    </section>

    <section>
      <h2>Examples</h2>
      <p>
        Below some <code><a>ExposedThing</a></code> interface examples are given.
      </p>

      <pre class="example highlight" title="Create a new exposed Thing with a simple property">
        try {
          var temperatureValueDefinition = {
            type: "number",
            value: 0.0,
            minimum: -50,
            maximum: 10000
          };
          var temperaturePropertyDefinition = temperatureValueDefinition;
          // add the 'forms' property
          temperaturePropertyDefinition.forms = [ ... ];
          var thing = WoT.produce({
            name: "tempSensor",
            properties: {
              temperature: temperaturePropertyDefinition
            },
            actions: {
              reset: {
                description: "Reset the temperature sensor",
                input: {
                  temperature: temperatureValueDefinition
                },
                output: null,
                forms: []
              },
            },
            events: {
              onchange: temperatureValueDefinition
            },
            links: []
          });
          thing.expose().then(() => {
              thing.register();
          });
          // define Thing business logic
          setInterval( async () => {
            let mock = Math.random()*100;
            thing.writeProperty("temperature", mock);
            let old = await thing.readProperty("temperature");
            if (old < mock) {
              thing.writeProperty("temperature", mock);
              thing.emitEvent("onchange", mock);
            }
          }, 1000);
        } catch (err) {
           console.log("Error creating ExposedThing: " + err);
        }
      </pre>

      <pre class="example highlight" title="Create a new exposed Thing with object property">
        try {
          var statusValueDefinition = {
            type: "object",
            properties: {
              brightness: {
                type: "number",
                minimum: 0.0,
                maximum: 100.0,
                required: true
              },
              rgb: {
                type: "array",
                "minItems": 3,
                "maxItems": 3,
                items : {
                    "type" : "number",
                    "minimum": 0,
                    "maximum": 255
                }
              }
          };
          var statusPropertyDefinition = statusValueDefinition;
          // add the 'forms' property
          statusPropertyDefinition["forms"] = [];
          var thing = WoT.produce({
            name: "mySensor",
            properties: {
              brightness: {
                type: "number",
                value: 0.0,
                minimum: 0.0,
                maximum: 100.0,
                required: true,
              },
              status: statusPropertyDefinition
            },
            actions: {
              status: {
                description: "Get status object",
                input: null,
                output: {
                  status : statusValueDefinition;
                },
                forms: []
              },
            },
            events: {
              onstatuschange: statusValueDefinition;
            },
            links: []
          });
          thing.expose().then(() => {
              thing.register();
          });
        } catch (err) {
           console.log("Error creating ExposedThing: " + err);
        }
      </pre>

      <pre class="example highlight" title="Create a new exposed Thing from a Thing Description">
        let thingDescription = '{ \
          "name": "mySensor", \
          "@context": [ "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",\
             "https://w3c.github.io/wot/w3c-wot-common-context.jsonld" ],\
          "@type": [ "Thing", "Sensor" ], \
          "geo:location": "testspace", \
          "properties": { \
            "prop1": { \
              "type": "number",\
              "@type": [ "Property", "Temperature" ], \
              "saref:TemperatureUnit": "degree_Celsius" \
          } } }';
        try {
          // note that produce() fails if thingDescription contains error
          let thing = WoT.produce(thingDescription);
          // Interactions were added from TD
          // WoT adds generic handler for reading any property
          // define a specific handler for one property
          let name = "examplePropertyName";
          thing.setPropertyReadHandler(name, () => {
            console.log("Handling read request for " + name);
            return new Promise((resolve, reject) => {
                let examplePropertyValue = 5;
                resolve(examplePropertyValue);
              },
              e => {
                console.log("Error");
              });
          });
          thing.expose();
        } catch(err) {
           console.log("Error creating ExposedThing: " + err);
        }
      </pre>

      <pre class="example highlight" title="Create a new exposed Thing from a TD URI">
        // fetch an external TD, e.g., to set up a proxy for that Thing
        WoT.fetch("http://myservice.org/mySensor/description").then(td => {
          // WoT.produce() ignores instance-specific metadata (security, form)
          let thing = WoT.produce(td);
          // Interactions were added from TD
          // add server functionality
          // ...
        });
      </pre>
    </section> <!-- ExposedThing Examples -->
  </section> <!-- ExposedThing -->

  <section>
    <h2>Data types used in a <a>Thing</a></h2>
    <p>
      Every <a>Thing</a> describes its metadata as defined in <a>ThingTemplate</a>, and basic interactions as defined in <a>ConsumedThing</a>: <a>Properties</a>, <a>Action</a>s and <a>Event</a>s. The following data types are used for representing these interactions, as defined in [[!WOT-TD]].
    </p>

    <section data-dfn-for="Link"><h3>The <dfn>Link</dfn> dictionary</h3>
      <pre class="idl">
        dictionary Link {
          required USVString href;
          USVString mediaType;
          DOMString rel;
        };
      </pre>
      <p>
        The <dfn>href</dfn> property is a hypertext reference that defines the <a>Link</a>.
      </p>
      <p>
        The <dfn>mediaType</dfn> property represents the <a>IANA media type</a> associated with the <a>Link</a>.
      </p>
      <p>
        The <dfn>rel</dfn> property represents a semantic label that specifies how to interact with the linked resource.
      </p>
    </section>

    <section data-dfn-for="WebLink"><h3>The <dfn>WebLink</dfn> dictionary</h3>
      <pre class="idl">
        dictionary WebLink: Link {
          USVString anchor;
        };
      </pre>
      <p>
        The <dfn>anchor</dfn> property represents a URI that overrides the default context of a <a>Link</a>.
      </p>
    </section>

    <section data-dfn-for="Form"><h3>The <dfn>Form</dfn> dictionary</h3>
      <pre class="idl">
        dictionary Form: Link {
          SecurityScheme security;
        };
      </pre>
      <p>
        The <dfn>security</dfn> property represents the security requirements for the linked resource.
      </p>
    </section>

    <section data-dfn-for="Interaction">
      <h3>The <dfn>Interaction</dfn> interface</h3>
      <p>
        The <a>Interaction</a> interface is an abstract class to represent <a>Thing</a> interactions: <a>Properties</a>, <a>Actions</a> and <a>Events</a>.
      </p>
      <p>
        The <a>InteractionInit</a> dictionary holds the common properties of <a>PropertyInit</a>, <a>ActionInit</a> and <a>EventInit</a> dictionaries used for initializing <a>ThingProperty</a>, <a>ThingAction</a> and <a>ThingEvent</a> objects in a <a>ThingTemplate</a> dictionary used for creating an <a>ExposedThing</a> object.
      </p>

      <pre class="idl">
        interface Interaction {
          attribute DOMString label;
          readonly attribute FrozenArray&lt;Form&gt; forms;
        };
        Interaction implements Observable;
      </pre>
      <p>
        The <dfn>label</dfn> property represents a text label for the interaction.
      </p>
      <p>
        The <dfn>forms</dfn> read-only property represents the protocol bindings initialization data and is initialized by the <a>WoT Runtime</a>.
      </p>

      <section data-dfn-for="InteractionInit"><h4>The <dfn>InteractionInit</dfn> dictionary</h4>
        <pre class="idl">
          dictionary InteractionInit {
            DOMString label;
          };
        </pre>
        <p>
          The <dfn>label</dfn> property initializes the text label for the interaction.
        </p>
      </section>

    </section>

    <section data-dfn-for="ThingProperty">
      <h3>The <dfn>ThingProperty</dfn> interface</h3>
      <p>
        The <a>ThingProperty</a> interface is used in <a>ConsumedThing</a> and <a>ExposedThing</a> objects to represent <a>Thing</a> <a>Property</a> interactions.
      </p>
      <p>
        The <a>PropertyInit</a> dictionary is used for initializing <a>Property</a> objects in a <a>ThingTemplate</a> dictionary used for creating an <a>ExposedThing</a> object. It MUST implement one of the <a>DataSchema</a> dictionaries.
      </p>
      <pre class="idl">
        interface ThingProperty: Interaction {
          // getter for PropertyInit properties
          getter any(DOMString name);
          // get and set interface for the Property
          Promise&lt;any&gt; get();
          Promise set(any value);
        };
        ThingProperty implements PropertyInit;
        ThingProperty implements Observable;
      </pre>
      <p>
        The <a>ThingProperty</a> interface contains all the properties defined on <a>PropertyInit</a> as read-only properties.
      </p>
      <p>
        The <dfn>type</dfn> read-only property represents the type definition for the <a>Property</a>. If it matches a <a>DataType</a>, then it MUST implement the corresponding <a>DataSchema</a> dictionary.
      </p>
      <p>
        The <dfn>writable</dfn> read-only property tells whether the <a>Property</a> value can be updated. If it is <code>false</code>, then the <code>set(value)</code> method SHOULD always reject.
      </p>
      <p>
        The <strong><em>observable</em></strong> read-only property tells whether the <a>Property</a> supports subscribing to value change notifications. If it is <code>false</code>, then the <code>subscribe()</code> method SHOULD always fail.
      </p>
      <p>
        The <strong><em>const</em></strong> read-only property - defined in <a>DataSchema</a> - tells whether the <a>Property</a> value is a constant. If <code>true</code>, the <code>set()</code> and <code>subscribe()</code> methods SHOULD always fail.
      </p>
      <p>
        The <strong><em>required</em></strong> read-only property  - defined in <a>DataSchema</a> - tells whether the <a>Property</a> should be always present on the <a>ExposedThing</a> object.
      </p>
      <p>
        The <dfn>get()</dfn> method will fetch the value of the <a>Property</a>. Returns a <a>Promise</a> that resolves with the value, or rejects with an error.
      </p>
      <p>
        The <dfn>set()</dfn> method will attempt to set the value of the <a>Property</a>specified in the <code>value</code> argument whose type SHOULD match the o9ne specified by the <code>type</code> property. Returns a <a>Promise</a> that resolves on success, or rejects on an error.
      </p>

      <section data-dfn-for="PropertyInit"><h4>The <dfn>PropertyInit</dfn> dictionary</h4>
        Defines the standardized part of the dictionary that initializes a <a>ThingProperty</a> object.
        <pre class="idl">
          dictionary PropertyInit: InteractionInit {
            boolean writable = false;
            boolean observable = false;
            any value;  // initialization value
          };
          PropertyInit implements DataSchema;
        </pre>
      <p>
        The <dfn>writable</dfn> property initializes access to the <a>Property</a> value. The default value is <code>false</code>.
      </p>
      <p>
        The <dfn>observable</dfn> property initializes observability access to the <a>Property</a>. The default value is <code>false</code>.
      </p>
        <p>
          The <dfn>value</dfn> property represents the initialization value of the property. Its type should match the one defined in the <code>type</code> property. If not provided in the dictionary object, it SHOULD be initialized as <code>undefined</code>.
        </p>
      </section>
    </section>

    <section data-dfn-for="ThingAction">
      <h3>The <dfn>ThingAction</dfn> interface</h3>
      <pre class="idl">
        interface ThingAction: Interaction {
          readonly attribute DataSchema? input;
          readonly attribute DataSchema? output;
          readonly attribute DOMString description;
          Promise&lt;any&gt; run(optional any inputValue);
        };
      </pre>
      <p>
        The <dfn>input</dfn> read-only property represents the input of type <a>DataSchema</a> to the <a>ThingAction</a>. Multiple arguments can be provided by applications as an array or as an object. If the value is <code>null</code>, the action does not take any arguments and rejects if any arguments are provided. If the value is <code>undefined</code>, the action will ignore any arguments provided.
      </p>
      <p>
        The <dfn>output</dfn> read-only property represents the output of type <a>DataSchema</a> of the <a>ThingAction</a>. If the value is <code>null</code> or <code>undefined</code>, the action does not return any values.
      </p>
      <p>
        The <dfn>description</dfn> read-only property represents a human-readable textual description of the <a>Action</a> interaction.
      </p>
      <p>
        The <dfn>run()</dfn> method when invoked, starts the <a>Action</a> interaction with the input value provided by the <var>inputValue</var> argument. If <var>inputValue</var> is <code>null</code>, the action does not take any arguments and rejects if any arguments are provided. If the value is <code>undefined</code>, the action will ignore any arguments provided. Otherwise the type of <var>inputValue</var> SHOULD match the <a>DataSchema</a> definition in the <code>input</code> property. Returns a <a>Promise</a> that will reject with an error or will resolve with a value of type defined by the <code>output</code> property.
      </p>

      <section data-dfn-for="ActionInit"><h4>The <dfn>ActionInit</dfn> dictionary</h4>
        <pre class="idl">
          dictionary ActionInit: InteractionInit {
            DataSchema? input;
            DataSchema? output;
            DOMString description;
          };
        </pre>
        <p>
          The <dfn>input</dfn> property initializes the input of type <a>DataSchema</a> to the <a>ThingAction</a>. Multiple arguments can be provided by applications as an array or as an object.
        </p>
        <p>
          The <dfn>output</dfn> property initializes the output of type <a>DataSchema</a> of the <a>ThingAction</a>.
        </p>
        <p>
          The <dfn>description</dfn> read-only property initializes a human-readable textual description of the <a>Action</a> interaction.
        </p>
      </section>
    </section>

    <section><h3>The <dfn>ThingEvent</dfn> interface</h3>
      <pre class="idl">
        interface ThingEvent {
        };
        ThingEvent implements ThingProperty;
      </pre>
      <p>
        The data events are carrying is represented as a <a>Property</a>. <a>ThingEvent</a> SHOULD also implement the event mechanism of the underlying platform (such as a DOM Event or a Node.js Event).
      </p>
      <section data-dfn-for="EventInit"><h4>The <dfn>EventInit</dfn> dictionary</h4>
        <pre class="idl">
          typedef PropertyInit EventInit;
        </pre>
        <p>
          The value an event is carrying is initialized as a <a>Property</a> value.
        </p>
      </section>
    </section>

    <section><h3>Value types</h3>
      <p>
        Value types are used in <a>Property</a>, <a>Event</a> and <a>Action</a> parameter definitions in a <a>ThingTemplate</a>. Basically correspond to a <a>JSON</a> object definition.
      </p>

      <section data-dfn-for="DataType"><h4>The <dfn>DataType</dfn> enumeration type</h4>
        <pre class="idl">
          enum DataType { "boolean", "integer", "number", "string", "object", "array", "null" };
        </pre>
        <p>
          Defines the types that values can take, i.e. "<dfn>null</dfn>" "<dfn>boolean</dfn>", "<dfn>integer</dfn>", "<dfn>number</dfn>", "<dfn>string</dfn>", "<dfn>object</dfn>" and "<dfn>array</dfn>".
        </p>
      </section>

      <section data-dfn-for="Number"><h4>The <dfn data-dfn-for="">Number</dfn> type</h4>
        <pre class="idl">
          typedef (long or unrestricted double) Number;
        </pre>
        <p>
          A number is either an integer or floating point number supported by the underlying platform. A number value may have associated a permited range between a minimum and maximum value.
        </p>
      </section>

      <section data-dfn-for="DataSchema"><h4>The <dfn>DataSchema</dfn> dictionary</h4>
        <pre class="idl">
          dictionary DataSchema {
            required DataType type;
            boolean required = "false";
            DOMString description;
            boolean const;
          };
        </pre>
        <p>
          Represents the common properties of a value type definition.
        </p>
        <p>
          The <dfn>type</dfn> property represents the value type enumerated in <a>DataType</a>.
        </p>
        <p>
          The <dfn>required</dfn> property tells whether this value is required to be speficied.
        </p>
        <p>
          The <dfn>description</dfn> property represents a textual description of the value.
        </p>
        <p>
          The <dfn>const</dfn> property tells whether this value is constant.
        </p>
      </section>

      <section data-dfn-for="NumberSchema"><h4>The <dfn>NumberSchema</dfn> dictionary</h4>
        <pre class="idl">
          dictionary NumberSchema: DataSchema {
            required DOMString type;
            Number minimum;
            Number maximum;
          };
        </pre>
        <p>
          The <dfn>type</dfn> property MUST have either the value <code>"number"</code> (representing a floating point number) or <code>"integer"</code> (representing an integer) as defined by the underlying platform.
        </p>
        <p>
          The <dfn>minimum</dfn> property may be present when the value is of type <code>"number"</code> and if present, it defines the minimum value that can be used.
        </p>
        <p>
          The <dfn>maximum</dfn> property may be present when the value is of type <code>"number"</code> and if present, it defines the maximum value that can be used.
        </p>
      </section>

      <section data-dfn-for="BooleanSchema"><h4>The <dfn>BooleanSchema</dfn> dictionary</h4>
        <pre class="idl">
          dictionary BooleanSchema: DataSchema {
            const type = "boolean";
          };
        </pre>
        <p>
          The <dfn>type</dfn> property MUST have the value <code>"boolean"</code>.
        </p>
      </section>

      <section data-dfn-for="StringSchema"><h4>The <dfn>StringSchema</dfn> dictionary</h4>
        <pre class="idl">
          dictionary StringSchema: DataSchema {
            const type = "string";
            sequence&lt;DOMString&gt;? enum;
          };
        </pre>
        <p>
          The <dfn>type</dfn> property MUST have the value <code>"string"</code>.
        </p>
        <p>
          The <dfn>enum</dfn> property represents the list of allowed string values as a string array.
        </p>
      </section>

      <section data-dfn-for="ObjectSchema"><h4>The <dfn>ObjectSchema</dfn> dictionary</h4>
        <pre class="idl">
          dictionary ObjectSchema: DataSchema {
            const type = "object";
            maplike&lt;DOMString, DataSchema&gt;? properties;
            sequence&lt;DOMString&gt; required;
          };
        </pre>
        <p>
          The <dfn>type</dfn> property MUST have the value <code>"object"</code>.
        </p>
        <p>
          The <dfn>properties</dfn> property is a dictionary that contains the names and types of each of the object properties. If not provided in the dictionary object, it SHOULD be initialized to <code>undefined</code>. The value <code>null</code> is accepted, as well as an empty object.
        </p>
        <p>
          The <dfn>required</dfn> property is a string array that containes the names that are mandatory to be present from the object properties. If not provided, it SHOULD be initialized to <code>undefined</code>. An empty array is accepted.
        </p>
      </section>

      <section data-dfn-for="ArraySchema"><h4>The <dfn>ArraySchema</dfn> dictionary</h4>
        <pre class="idl">
          dictionary ArraySchema: DataSchema {
            const type = "array";
            DataSchema? items;
            unsigned long minItems;
            unsigned long maxItems;
          };
        </pre>
        <p>
          The <dfn>type</dfn> property MUST have the value <code>"array"</code>.
        </p>
        <p>
          The <dfn>items</dfn> property represents the type of the elements in the array. If not provided in the dictionary object, it SHOULD be initialized to <code>"undefined"</code>. The value <code>null</code> is accepted.
        </p>
        <p>
          The <dfn>minItems</dfn> property represents the minimum number of elements required to be in the array.
        </p>
        <p>
          The <dfn>maxItems</dfn> property represents the maximum number of elements that can be specified in the array.
        </p>
      </section>
    </section>

    <section><h3>The <dfn>value-matching algorithm</dfn></h3>
      <p>
        The value-matching algorithm is applied to a <var>value</var> input in relation to a <var>valueType</var> property of type <a>DataSchema</a>, for instance the <code>value</code> and <code>type</code> properties of a <a>PropertyInit</a> object, or the <var>inputValue</var> parameter to the <code>run()</code> method of a <a>ThingAction</a> object in relation to the same object. It executes the following steps:
        <ol>
          <li>
            If <var>valueType.type</var> is not defined, or does not fully match a string enumerated in <a>DataType</a>, return <code>false</code>.
          </li>
          <li>
            Otherwise, if <var>valueType.type</var> is <code>"null"</code>: if <var>value</var> is <code>null</code>, return <code>true</code>, otherwise return <code>false</code>.
          </li>
          <li>
            Otherwise, if <var>valueType.type</var> is <code>"boolean"</code>: if <var>value</var> is either <code>true</code> or <code>false</code>, then return <code>true</code>, otherwise return <code>false</code>.
          </li>
          <li>
            Otherwise, if <var>valueType.type</var> is <code>"integer"</code>: if <var>value</var> is not an integer type defined by the underlying platform (such as <code>long</code> or <code>long long</code>), then return <code>false</code>, otherwise execute the following sub-steps:
            <ol>
              <li>
                If <var>valueType.minimum</var> is defined and <var>value</var> is not greater or equal than that value, return <var>false</var>.
              </li>
              <li>
                If <var>valueType.maximum</var> is defined and <var>value</var> is not less or equal than that value, return <var>false</var>.
              </li>
              <li>
                Return <code>true</code>.
              </li>
            </ol>
          </li>
          <li>
            Otherwise, if <var>valueType.type</var> is <code>"number"</code>, if <var>value</var> is not an integer or floating point type defined by the underlying platform (such as <code>long</code> or <code>long long</code> or <code>double</code>), then return <code>false</code>, otherwise otherwise execute the following sub-steps:
            <ol>
              <li>
                If <var>valueType.minimum</var> is defined and <var>value</var> is not greater or equal than that value, return <var>false</var>.
              </li>
              <li>
                If <var>valueType.maximum</var> is defined and <var>value</var> is not less or equal than that value, return <var>false</var>.
              </li>
              <li>
                Return <code>true</code>.
              </li>
            </ol>
          </li>
          <li>
            Otherwise, if <var>valueType.type</var> is <code>"string"</code>: if <var>value</var> is not a string type defined by the underlying platform, then return <code>false</code>, otherwise return <code>true</code>. In this case the algorithm expects a third parameter <var>valueType.enum</var> and runs the following sub-steps:
            <ul>
              <li>
                If <var>valueType.enum</var> is an array of strings, then if <var>value</var> fully matches one of the strings defined in the array, return <var>true</var>.
              </li>
              <li>
                Otherwise, return <var>false</var>.
              </li>
            </ul>
          </li>
          <li>
            Otherwise, if <var>valueType.type</var> is <code>"array"</code>, execute the following sub-steps:
            <ol>
              <li>
                If <var>valueType.minItems</var> is defined, and <var>value</var> is not an array that contains at least <var>valueType.minItems</var> elements, return <var>false</var>.
              </li>
              <li>
                If <var>valueType.maxItems</var> is defined, and <var>value</var> is not an array that contains at maximum <var>valueType.maxItems</var> elements, return <var>false</var>.
              </li>
              <li>
                Otherwise, if <var>value</var> is not an array, return <code>false</code>.
              </li>
              <li>
                Otherwise, if <var>valueType.items</var> is <code>undefined</code>, return <code>false</code>.
              </li>
              <li>
                Otherwise, if <var>valueType.items</var> is <code>null</code>, return <code>true</code> (i.e. any type is accepted as array element, including heterogenous arrays).
              </li>
              <li>
                Otherwise, for each element of the array <var>value</var> run the <a>value-matching algorithm</a> against the <var>valueType.items</var> object. If any of these runs returns <code>false</code>, then return <code>false</code>.
              </li>
              <li>
                Otherwise, return <code>true</code>.
              </li>
            </ol>
          </li>
          <li>
            Otherwise, if <var>type</var> is <code>"object"</code>, execute the following sub-steps:
            <ol>
              <li>
                If <var>value</var> is not an <code>Object</code> or <code>null</code>, return <code>false</code>.
              </li>
              <li>
                If <var>valueType.properties</var> is not defined or is not <code>null</code> or it is not an object, return <code>false</code>.
              </li>
              <li>
                If <var>valueType.properties</var> is <code>null</code>, return <code>true</code> (i.e. accept any object value).
              </li>
              <li>
                For each string in the <var>valueType.required</var> array, if it does not match a property name in the <var>value.properties</var> object or in the <var>value</var> object, then return <code>false</code>.
              </li>
              <li>
                For each property with name <var>propName</var> and value <var>propDataSchema</var> found in <var>valueType.properties</var>, run the following sub-steps:
                <ol>
                  <li>
                    If the result of applying the <a>value-matching algorithm</a> on the value <var>value[propName]</var> and <var>propDataSchema</var> is <var>false</var>, then return <var>false</var>.
                  </li>
                </ol>
              </li>
              <li>
                Return <code>true</code>.
            </ol>
          </li>
        </ol>
      </p>
    </section>

  </section>

  <section data-dfn-for="Observable" class="informative">
    <h2>Observables</h2>
    <p>
      <dfn>Observables</dfn> are <a href="https://github.com/tc39/proposal-observable">proposed</a> to be included in ECMAScript and are used for handling pushed data associated with various possible sources, for instance events, timers, streams, etc. A minimal required implementation is described here.
    </p>
    <p class="ednote">
      This section is informal and contains rather laconic information for implementations on what to support for interoperability.
    </p>
    <pre class="idl">
      interface Observable {
        Subscription subscribe((Observer or OnNext) next,
                               optional OnError error,
                               optional OnComplete complete);
      };
      interface Subscription {
        void unsubscribe();
        readonly attribute boolean closed;
      };
      interface Observer {
        void next(any value);
        void error(Error error);
        void complete();
      };
      callback OnNext = void (any value);
      callback OnError = void (Error error);
      callback OnComplete = void ();
    </pre>

    <section data-dfn-for="Observer">
      <h3>The <dfn>Observer</dfn> interface</h3>
      <p>
        The <a>Observer</a> interface defines the callbacks needed to handle an <a>Observable</a>:
      </p>
      <ul>
        <li>
          The <dfn>next()</dfn> function, as well as the <dfn>OnNext</dfn> callback takes the next sample for the data in the <code>value</code> argument.
        </li>
        <li>
          The <dfn>error()</dfn> function, as well as the <dfn>OnError</dfn> callback takes an error in the <code>value</code> argument. It is called when an error occured in producing the data the client should know about.
        </li>
        <li>
          The <dfn>complete()</dfn> function, as well as the <dfn>OnComplete</dfn> callback is called when the data source has finished sending values.
        </li>
      </ul>
    </section>

    <section data-dfn-for="Subscription">
      <h3>The <dfn>Subscription</dfn> interface</h3>
      <p>
        Contains the <dfn>closed</dfn> property of type <code>boolean</code> that tells if the subscription is closed or active.
      </p>
      <p>
        Also, contains the <dfn>unsubscribe</dfn>() method that cancels the subscription, i.e. makes a request to the underlying platform to stop receiving data from the source, and sets the <code>closed</code> property to <code>false</code>.
      </p>
    </section>

    <section data-dfn-for="Observable">
      <h3>The <dfn data-dfn-for="">Observable</dfn> interface</h3>
      <p>
        The <a>Observable</a> interface enabled subscribing to pushed data notifications by the <dfn>subscribe</dfn>() method:
      </p>
      <ul>
        <li>
          If the <code>subscribe()</code> method is called with an <a>Observer</a> object, initialize the data, error and completion handling callbacks from that object, or throw on error.
        </li>
        <li>
          Otherwise, if the <code>subscribe()</code> method is called with a function, initialize the data handler callback with that function. If the next argument is provided and is a function, initialize the error handling callback with that function, or throw on error. If the third argument is provided and is a function, initialize the completion handler with that function, or throw on error.
        </li>
        <li>
          After callback initializations, the implementation should request the underlying platform to provide data, error and completion notifications for the supported data source.
        </li>
      </ul>
    </section>
  </section> <!-- Observables -->

  <section> <h2 id="security">Security and Privacy</h2>
    <p class="ednote">
     Please see the <a href="https://github.com/w3c/wot-security/">WoT Security and Privacy</a> repository for work in progress regarding threat models, assets, risks, recommended mitigations, and best practices for security and privacy for systems using the Web of Things. Once complete, security and privacy considerations relevant to the Scripting API will be summarized in this section.
    </p>

    <section data-dfn-for="SecuritySchemeType"><h4>The <dfn>SecuritySchemeType</dfn> enumeration type</h4>
      <pre class="idl">
        enum SecuritySchemeType { "basic", "digest", "bearer", "pop", "oauth2", "apikey" };
      </pre>
      <p>
        Defines the supported security schemes, i.e. "<dfn>basic</dfn>", "<dfn>digest</dfn>", "<dfn>bearer</dfn>", "<dfn>pop</dfn>", "<dfn>oauth2</dfn>" and "<dfn>apikey</dfn>".
      </p>
    </section>

    <section data-dfn-for="AuthenticationType"><h4>The <dfn>AuthenticationType</dfn> enumeration type</h4>
      <pre class="idl">
        enum AuthenticationType { "header", "body", "query", "cookie" };
      </pre>
      <p>
        Defines the  location of the authentication information, i.e. "<dfn>header</dfn>", "<dfn>body</dfn>", "<dfn>query</dfn>" and "<dfn>cookie</dfn>".
      </p>
    </section>

    <section data-dfn-for="SecurityScheme" >
      <h3> The <dfn data-dfn-for="">SecurityScheme</dfn> dictionary</h3>
      <p>
        Represents the base class for security related configuration. One of the subclasses (differentiated by <code>scheme</code>) SHOULD be used.
      </p>
      <pre class="idl">
        dictionary SecurityScheme {
          required SecuritySchemeType scheme;
        };
      </pre>
      <p>
        The <dfn>scheme</dfn> property represents the identification of the security scheme to be used for the <a>Thing</a>.
      </p>
    </section>

    <section data-dfn-for="BasicSecurityScheme" >
      <h3> The <dfn data-dfn-for="">BasicSecurityScheme</dfn> dictionary</h3>
      <pre class="idl">
        dictionary BasicSecurityScheme: SecurityScheme {
          const scheme = "basic";
          DOMString in;
          DOMString pname;
        };
      </pre>
      <p>
        The <dfn>scheme</dfn> property represents the identification of the security scheme to be used for the <a>Thing</a>.
      </p>
      <p>
        The <dfn>in</dfn> property of type <a>AuthenticationType</a> represents represents the location of the authentication information.
      </p>
      <p>
        The <dfn>pname</dfn> property represents the authentication parameter name.
      </p>
    </section>

    <section data-dfn-for="DigestSecurityScheme" >
      <h3> The <dfn data-dfn-for="">DigestSecurityScheme</dfn> dictionary</h3>
      <pre class="idl">
        dictionary DigestSecurityScheme: BasicSecurityScheme {
          const scheme = "digest";
          DOMString qop = "auth";
        };
      </pre>
      <p>
        The <dfn>scheme</dfn> property represents the identification of the security scheme and MUST be <code>"digest"</code>.
      </p>
      <p>
        The <dfn>qop</dfn> property represents the quality of protection. The default value is <code>"auth"</code>. The other accepted value is <code>"auth-int"</code>.
      </p>
    </section>

    <section data-dfn-for="BearerSecurityScheme" >
      <h3> The <dfn data-dfn-for="">BearerSecurityScheme</dfn> dictionary</h3>
      <pre class="idl">
        dictionary BearerSecurityScheme: BasicSecurityScheme {
          const scheme = "bearer";
          USVString authorizationURL;
          DOMString alg = "ES256";
          DOMString format = "jwt";
        };
      </pre>
      <p>
        The <dfn>scheme</dfn> property represents the identification of the security scheme and MUST be <code>"bearer"</code>.
      </p>
      <p>
        The <dfn>authorizationURL</dfn> property represents the authorization server URL.
      </p>
      <p>
        The <dfn>alg</dfn> property represents the encoding, encryption or digest algorithm. Accepted values include <code>"MD5"</code>, <code>"ES256"</code>, <code>"ES512-256"</code>. The default value is <code>"ES256"</code>.
      </p>
      <p>
        The <dfn>format</dfn> property represents the format of the authentication information. Accepted values are <code>"jwt"</code> (the default value), <code>"jwe"</code> and <code>"jws"</code>.
      </p>
    </section>

    <section data-dfn-for="PopSecurityScheme" >
      <h3> The <dfn data-dfn-for="">PopSecurityScheme</dfn> dictionary</h3>
      <p>
        Represents the proof-of-possession token authentication security configuration.
      </p>
      <pre class="idl">
        dictionary PopSecurityScheme: DigestSecurityScheme {
          const scheme = "pop";
        };
      </pre>
      <p>
        The <dfn>scheme</dfn> property represents the identification of the security scheme and MUST be <code>"pop"</code>.
      </p>
    </section>

    <section data-dfn-for="ApikeySecurityScheme" >
      <h3> The <dfn data-dfn-for="">ApikeySecurityScheme</dfn> dictionary</h3>
      <p>
        Represents the API key authentication security configuration, where the access token is opaque and is not using a standard token format.
      </p>
      <pre class="idl">
        dictionary ApikeySecurityScheme: BasicSecurityScheme {
          const scheme = "apikey";
        };
      </pre>
      <p>
        The <dfn>scheme</dfn> property represents the identification of the security scheme and MUST be <code>"apikey"</code>.
      </p>
    </section>

    <section data-dfn-for="OAuth2SecurityScheme" >
      <h3> The <dfn data-dfn-for="">OAuth2SecurityScheme</dfn> dictionary</h3>
      <p>
        Represents the OAuth2 authentication security configuration.
      </p>
      <pre class="idl">
        dictionary OAuth2SecurityScheme: SecurityScheme {
          const scheme = "oauth2";
          USVString tokenURL;
          USVString authorizationURL;
          USVString refreshURL;
          sequence&lt;DOMString&gt; scopes;
          DOMString flow = "implicit";
        };
      </pre>
      <p>
        The <dfn>scheme</dfn> property represents the identification of the security scheme and MUST be <code>"oauth2"</code>.
      </p>
      <p>
        The <dfn>tokenURL</dfn> property represents the URL of the token server.
      </p>
      <p>
        The <dfn>authorizationURL</dfn> property represents the URL of the authorization server.
      </p>
      <p>
        The <dfn>refreshURL</dfn> property represents the URL of the refresh server.
      </p>
      <p>
        The <dfn>scopes</dfn> property represents the authorization scope identifiers as an array of strings.
      </p>
      <p>
        The <dfn>flow</dfn> property represents the authorization flow of type. Accepted values are: <code>"implicit"</code> (the default value), <code>"password"</code>, <code>"client"</code>, or <code>"code"</code>.
      </p>
      <p>
         For the <code>"implicit"</code> flow the <code>authorizationURL</code> and <code>scopes</code> properties are required. For the <code>"password"</code> and <code>"client"</code> flows the <code>tokenURL</code> and <code>scopes</code> properties are required. For the <code>"code"</code> flow the <code>authorizationURL</code>, <code>tokenURL</code> and <code>scopes</code> properties are required.
      </p>
    </section>
  </section>

  <section> <h2>Terminology and conventions</h2>
    <p>
      The generic WoT terminology is defined in [[!WOT-ARCHITECTURE]]: <dfn data-lt="Things">Thing</dfn>, <dfn data-lt="Thing Descriptions">Thing Description</dfn> (in short <dfn>TD</dfn>), <dfn>Web of Things</dfn> (in short <b><i>WoT</i></b>),  <dfn>WoT Interface</dfn>, <dfn>Protocol Bindings</dfn>, <dfn>WoT Runtime</dfn>, <dfn data-lt="consume|consume a TD|consuming a TD">Consuming a Thing Description</dfn>, <dfn>Thing Directory</dfn>, <dfn>WoT Interactions</dfn>, <dfn data-lt="Properties">Property</dfn>, <dfn data-lt="Actions">Action</dfn>, <dfn data-lt="Events|WoT-Event">Event</dfn> etc.
    </p>
    <p>
      <dfn>JSON-LD</dfn> is defined in [[!JSON-LD]] as a JSON document that is augmented with support for Linked Data.
    </p>
    <p>
      The terms <a href="http://www.w3.org/TR/url-1/"><dfn>URL</dfn></a> and
      <a href="https://url.spec.whatwg.org/#concept-url-path">
      <dfn>URL path</dfn></a> are defined in [[!URL]].
    </p>
    <p>
      The following terms are defined in [[!HTML5]] and are used in the context of browser implementations:
      <a href="https://html.spec.whatwg.org/multipage/browsers.html#browsing-context">
      <dfn>browsing context</dfn></a>,
      <a href="https://html.spec.whatwg.org/#top-level-browsing-context">
      <dfn>top-level browsing context</dfn></a>,
      <a href="https://html.spec.whatwg.org/multipage/webappapis.html#global-object">
      <dfn>global object</dfn></a>,
      <a href="http://www.w3.org/TR/html5/webappapis.html#incumbent-settings-object">
      <dfn>incumbent settings object</dfn></a>,
      <a href="https://html.spec.whatwg.org/#document">
      <dfn>Document</dfn></a>,
      <a href="http://www.w3.org/TR/2011/WD-html5-20110113/urls.html#document-base-url">
      <dfn>document base URL</dfn></a>,
      <a href="https://html.spec.whatwg.org/#window">
      <dfn>Window</dfn></a>,
      <a href="https://html.spec.whatwg.org/#windowproxy">
      <dfn>WindowProxy</dfn></a>,
      <a href="https://html.spec.whatwg.org/#origin">
      <dfn>origin</dfn></a>,
      <a href="https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin">
      <dfn>ASCII serialized origin</dfn></a>,
      executing algorithms <a href="https://html.spec.whatwg.org/#in-parallel">
      <dfn>in parallel</dfn></a>,
      <a href="https://html.spec.whatwg.org/#queue-a-task">
      <dfn>queue a task</dfn></a>,
      <a href="https://html.spec.whatwg.org/#task-source">
      <dfn>task source</dfn></a>,
      <a href="https://html.spec.whatwg.org/#the-iframe-element">
      <dfn>iframe</dfn></a>,
      <a href="https://html.spec.whatwg.org/#valid-mime-type">
      <dfn>valid MIME type</dfn></a>.
    </p>
    <p>
      A <a>browsing context</a> refers to the environment in which
      <a>Document</a> objects are presented to the user. A given
      <a>browsing context</a> has a single <code><a>WindowProxy</a></code> object,
      but it can have many <code><a>Document</a></code> objects, with their associated
      <code><a>Window</a></code> objects. The <a>script execution context</a>
      associated with the <i>browsing context</i> identifies the entity which
      invokes this API, which can be a <i>web app</i>, a <i>web page</i>, or an
      <a>iframe</a>.
    </p>
    <p>
      The term
      <a href="https://w3c.github.io/webappsec/specs/powerfulfeatures/#secure-context">
      <dfn>secure context</dfn></a> is defined in [[!WEBAPPSEC]].
    </p>
    <p>
      <a href="https://tc39.github.io/ecma262/#sec-error-objects">
      <dfn>Error</dfn>, <dfn>EvalError</dfn>, <dfn>RangeError</dfn>, <dfn>ReferenceError</dfn>, <dfn>SyntaxError</dfn>, <dfn>TypeError</dfn>, <dfn>URIError</dfn>
      </a>,
      <a href="https://tc39.github.io/ecma262/#sec-execution-contexts">
        <dfn>script execution context</dfn></a>,
      <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">
        <dfn>Promise</dfn></a>,
      <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-json-object">
        <dfn>JSON</dfn></a>,
      <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-json.stringify">
        <dfn>JSON.stringify</dfn></a> and
      <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-json.parse">
        <dfn>JSON.parse</dfn></a>
      are defined in [[!ECMASCRIPT]].
    </p>
    <p>
      <a href="http://heycam.github.io/webidl/#idl-DOMString"><dfn>DOMString</dfn></a>,
      <a href="https://heycam.github.io/webidl/#idl-USVString"><dfn>USVString</dfn></a>,
      <a href="http://heycam.github.io/webidl/#idl-ArrayBuffer"><dfn>ArrayBuffer</dfn></a>,
      <a href="http://heycam.github.io/webidl/#common-BufferSource"><dfn>BufferSource</dfn></a> and
      <a href="http://heycam.github.io/webidl/#idl-any"><dfn>any</dfn></a> are defined in [[!WEBIDL]].
    </p>
    <p>
      The algorithms <a href="http://www.w3.org/TR/encoding/#utf-8-encode">
      <dfn>utf-8 encode</dfn></a>, and
      <a href="http://www.w3.org/TR/encoding/#utf-8-decode">
      <dfn>utf-8 decode</dfn></a> are defined in [[!ENCODING]].
    </p>
    <p>
      <dfn>IANA media type</dfn>s (formerly known as MIME types) are defined in
      <a href="http://tools.ietf.org/html/rfc2046">RFC2046</a>.
    </p>
    <p>
      The terms <dfn>hyperlink reference</dfn> and <dfn>relation type</dfn> are defined in [[!HTML5]] and <a href="https://tools.ietf.org/html/rfc8288">RFC8288</a>.
    </p>
  </section>

  <section id="conformance">
    <p>
      This document defines conformance criteria that apply to a single product: the <dfn>UA</dfn> (user agent) that implements the interfaces it contains.
    </p>
    <p>
      This specification can be used for implementing the WoT Scripting API in multiple programming languages. The interface definitions are specified in [[!WEBIDL]].
    </p>
    <p>
      The user agent (UA) may be implemented in the browser, or in a separate runtime environment, such as [Node.js](https://nodejs.org/en/) or small embedded runtimes.
    </p>
    <p>
      Implementations that use ECMAScript executed in a browser to implement the APIs defined in this document MUST implement them in a manner consistent with the ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]].
    </p>
    <p>
      Implementations that use TypeScript or ECMAScript in a runtime to implement the APIs defined in this document MUST implement them in a manner consistent with the TypeScript Bindings defined in the TypeScript specification [[!TYPESCRIPT]].
    </p>
    <p>
      This document serves a general description of the WoT Scripting API. Language and runtime specific issues are discussed in separate extensions of this document.
    </p>
  </section>

  <section class="appendix" id="Changes"><h2>Changes</h2>
    <p>
      The following is a list of major changes to the document. For a complete list of changes, see the [github change log](https://github.com/w3c/wot-scripting-api/commits/master). You can also view the [recently closed bugs](https://github.com/w3c/wot-scripting-api/issues?page=1&amp;state=closed).
    </p>
    <p>
      <ul>
        <li>
          Synchronized the Scripting API with the [Thing Description specification](https://w3c.github.io/wot-thing-description/). Defined <code>ThingDescription</code>, <code>ThingTemplate</code>, data type descriptions, etc. Refined discovery filtering.
        </li>
      </ul>
    </p>
  </section>

  <section> <h3 class="appendix" id="openissues">Open issues</h3>
    <p>
      The following problems are being discussed and need most attention:
    </p>
      <ul>
        <li>
          Security related metadata (https://github.com/w3c/wot-scripting-api/issues/91).
        </li>
        <li>
          Providing Protocol Binding for <a>ExposedThing</a> (https://github.com/w3c/wot-scripting-api/issues/45).
        </li>
        <li> Script management and runtime related issues (https://github.com/w3c/wot-scripting-api/issues/) </li>
      </ul>
  </section>

  <section> <h2>Acknowledgements</h2>
    <p>
      Special thanks to former editor Johannes Hund (until August 2017, when at Siemens AG) for developing this specification. Also, the editors would like to thank Dave Raggett, Matthias Kovatsch, Michael Koster and Michael McCool for their comments and guidance.
    </p>
  </section>

  </body>
</html>
