<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Web of Things (WoT) Scripting API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script class='remove'>
      // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
      var respecConfig = {
        specStatus:           "ED",
        processVersion:       2023,
        shortName:            "wot-scripting-api",
        copyrightStart:       2017,
        group:                "wg/wot",
        noRecTrack:           true,
        noLegacyStyle:        true,
        wgPublicList:         "public-wot-wg",
        edDraftURI:           "https://w3c.github.io/wot-scripting-api/",
        github:               "https://github.com/w3c/wot-scripting-api/",
        issueBase:            "https://www.github.com/w3c/wot-scripting-api/issues/",
        crEnd:                "",
        inlineCSS:            true,
        noIDLIn:              true,
        noRecTrack:           true,
        editors: [
          { name: "Zoltan Kis", w3cid: "57789", company: "Intel Corp.", companyURL: "https://www.intel.com/" },
          { name: "Daniel Peintner", w3cid: "39497", company: "Siemens AG", companyURL: "https://www.siemens.com/" },
          { name: "Cristiano Aguzzi", w3cid: "105495", company: "Invited Expert", companyURL: "https://github.com/relu91" },
          { name: "Johannes Hund", w3cid: "74472", note: "Former Editor, when at Siemens AG" },
          { name: "Kazuaki Nimura", w3cid: "59208", note: "Former Editor, at Fujitsu Ltd." },
        ],
        otherLinks: [
          {
            key: "Repository",
            data: [{
                  value: "On GitHub",
                  href: "https://github.com/w3c/wot-scripting-api"
              }, {
                  value: "File a bug",
                  href: "https://github.com/w3c/wot-scripting-api/issues"
              },
            ]
          },
          {
            key: "Contributors",
            data: [
                {
                  value: "Contributors on GitHub",
                  href: "https://github.com/w3c/wot-scripting-api/graphs/contributors"
                }
            ]
          },
        ],
        xref: ["web-platform", "HTML", "INFRA", "URL", "WEBIDL", "DOM", "FETCH",
               "ecmascript", "streams",
               "wot-architecture", "wot-thing-description", "wot-binding-templates"],
        localBiblio: {
          "WOT-ARCHITECTURE" : {
            href:"https://www.w3.org/TR/2023/CR-wot-architecture11-20230119/",
            title: "Web of Things (WoT) Architecture 1.1",
            publisher: "W3C",
            date: "19 January 2023"
          },
          "WOT-TD" : {
            href:"https://www.w3.org/TR/2023/CR-wot-thing-description11-20230119/",
            title: "Web of Things (WoT) Thing Description 1.1",
            publisher: "W3C",
            date: "19 January 2023"
          },
          "WOT-DISCOVERY" : {
            href:"https://www.w3.org/TR/2023/CR-wot-discovery-20230119/",
            title: "Web of Things (WoT) Discovery",
            publisher: "W3C",
            date: "19 January 2023"
          },
          "WOT-PROTOCOL-BINDINGS" : {
            href: "https://www.w3.org/TR/2020/NOTE-wot-binding-templates-20200130/",
            title: "Web of Things (WoT) Binding Templates",
            publisher: "W3C",
            date: "30 January 2020"
          },
          "WOT-SECURITY" : {
              href: "https://www.w3.org/TR/2019/NOTE-wot-security-20191106/",
            title: "Web of Things (WoT) Security and Privacy Guidelines",
            publisher: "W3C",
            date: "6 November 2019"
          },
          "WOT-USE-CASES" : {
            href:"https://www.w3.org/TR/2022/NOTE-wot-usecases-20220307/",
            title: "Web of Things (WoT): Use Cases and Requirements",
            publisher: "W3C",
            date: " 7 March 2022"
          },
          "TYPESCRIPT": {
            href: "https://www.typescriptlang.org/docs/handbook/intro.html",
            title: "TypeScript Language Specification",
            publisher: "Microsoft",
            date: "1 October 2012"
          },
          "WEBAPPSEC": {
            href:"https://w3c.github.io/webappsec/specs/powerfulfeatures",
            title: "Secure Contexts",
            publisher: "W3C",
            date: "18 September 2021"
          },
        },
      };
    </script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // Add example button selection logic
        for (const button of document.querySelectorAll(".ds-selector-tabs .selectors button")) {
          button.onclick = () => {
            const ex = button.closest(".ds-selector-tabs");
            ex.querySelector("button.selected").classList.remove("selected");
            ex.querySelector(".selected").classList.remove("selected");
            button.classList.add('selected');
            ex.querySelector("." + button.dataset.selects).classList.add("selected");
          }
        }
      });
    </script>
    <style>
    /* example tab selection */
  .ds-selector-tabs {
    padding-bottom: 2em;
  }
  .ds-selector-tabs .selectors {
    padding: 0;
    border-bottom: 1px solid #ccc;
    height: 28px;
  }
  .ds-selector-tabs .selectors button {
    display: inline-block;
    min-width: 54px;
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    height: 27px;
    padding: 0 8px;
    line-height: 27px;
    transition: all,0.218s;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    color: #666;
    border: 1px solid transparent;
  }
  .ds-selector-tabs .selectors button:first-child {
    margin-left: 2px;
  }
  .ds-selector-tabs .selectors button.selected {
    color: #202020 !important;
    border: 1px solid #ccc;
    border-bottom: 1px solid #fff !important;
  }
  .ds-selector-tabs .selectors button:hover {
    background-color: transparent;
    color: #202020;
    cursor: pointer;
  }
  .ds-selector-tabs pre:not(.preserve), .ds-selector-tabs table:not(.preserve) {
    display: none;
  }
  .ds-selector-tabs pre.selected, .ds-selector-tabs table.selected {
    display: block;
  }
    </style>
  </head>
  <body>

  <section id="abstract">
    <p>
      The Web of Things is made of entities (<a>Thing</a>s) that can describe their capabilities in a machine-interpretable <a>Thing Description</a> (TD) and expose these capabilities through the <a>WoT Interface</a>, that is, network interactions modeled as <a>Properties</a> (for reading and writing values), <a>Action</a>s (to execute remote procedures with or without return values) and <a>Event</a>s (for signaling notifications).
    </p>
    <p>
      The main <a>Web of Things</a> (WoT) concepts are described in the [[[WOT-ARCHITECTURE]]] specification.
    </p>
    <p>
      Scripting is an optional building block in WoT and it is typically used in gateways or browsers that are able to run a <a>WoT Runtime</a> and
      <a href="https://github.com/w3c/wot-scripting-api/tree/master/applications/script-manager">script management</a>, providing a convenient way to extend WoT support to new types of endpoints and implement WoT applications such as <a href="https://github.com/w3c/wot-scripting-api/tree/master/applications/thing-directory">TD Directory</a>.
    </p>
    <p>
      This specification describes an application programming interface (API) representing the <a>WoT Interface</a> that allows scripts to discover, operate <a>Thing</a>s and to expose locally defined <a>Thing</a>s characterized by <a> WoT Interactions</a> specified by a script.
    </p>
    <p>
      The APIs defined in this document deliberately follow the [[[WOT-TD]]] specification closely. It is possible to implement more abstract APIs on top of them, or implementing directly the WoT network facing interface (i.e. the <a>WoT Interface</a>).
    </p>
    <p class="ednote">
      This specification is implemented at least by the <a href="https://www.thingweb.io/">Eclipse Thingweb</a>
      project also known as <a href="https://github.com/eclipse-thingweb/node-wot">node-wot</a>, which is considered the reference open source implementation at the moment. Check its <a href="https://github.com/eclipse-thingweb/node-wot"> source code</a>, including <a href="https://github.com/eclipse-thingweb/node-wot/tree/master/examples">examples</a>.
    </p>
  </section>

  <section id="sotd">
    <p>
      Implementers need to be aware that this specification is considered unstable. Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation phase should subscribe to the <a href="https://github.com/w3c/wot-scripting-api">repository</a> and take part in the discussions.
    </p>
    <p class="ednote" title="The W3C WoT WG is asking for feedback">
      Please contribute to this draft using the <a href="https://github.com/w3c/wot-scripting-api/issues">GitHub Issues</a> page of the <a href="https://github.com/w3c/wot-scripting-api/">WoT Scripting API</a> repository.
      For feedback on security and privacy considerations, please use the <a href="https://github.com/w3c/wot-security/issues">WoT Security and Privacy</a> Issues.
    </p>
  </section>

  <section id="introduction"> <h2>Introduction</h2>
    <p>
      WoT provides layered interoperability based on how <a>Thing</a>s are used:
      "consumed" and "exposed", as defined in the [[[WOT-ARCHITECTURE]]] terminology.
    </p>
    <p>
      By <a>consuming a TD</a>, a client <a>Thing</a> creates a local runtime resource model that allows accessing the <a>Properties</a>, <a>Actions</a> and <a>Events</a> exposed by the server <a>Thing</a> on a remote device.
    </p>
    <div>
      Exposing a <a>Thing</a> requires:
      <ul>
        <li>
          defining a <a>Thing Description</a> (TD),
        </li>
        <li>
          then instantiating a software stack that implements the <a>WoT Interface</a> specified by the <a>TD</a> in order to serve requests for accessing the exposed <a>Properties</a>, <a>Actions</a> and <a>Events</a>,
        </li>
        <li>
           then eventually publishing the <a>Thing Description</a> (for instance to a <a>TD Directory</a> for easier discovery).
        </li>
      </ul>
      This specification describes how to expose and consume <a>Thing</a>s by a script. Also, it defines a generic API for <a>Thing</a> discovery.
    </div>
    <p class="note">
      Typically scripts are meant to be used on bridges or gateways that expose and control simpler devices as WoT <a>Thing</a>s and have means to handle (e.g. install, uninstall, update etc.) and run scripts.
    </p>
    <p class="note">
      This specification does not make assumptions on how the <a>WoT Runtime</a> handles and runs scripts, including single or multiple tenancy, script deployment and lifecycle management. The API already supports the generic mechanisms that make it possible to implement script management, for instance by exposing a manager <a>Thing</a> whose <a>Actions</a> (action handlers) implement script lifecycle management operations.
    </p>
    <!--
    <p>
      For an introduction on how scripts could be used in <a>Web of Things</a>, check the <a href="https://w3c.github.io/wot-scripting-api/primer">Primer</a> document. For some background on API design decisions check the <a href="https://w3c.github.io/wot-scripting-api/rationale">Rationale</a> document.
    </p>
    -->
  </section>

  <section class="informative"> <h3>Use Case Scenarios</h3>
    <p>
      The business use cases listed in the [[WOT-USE-CASES]] document may be
      implemented using this API, based on the scripting use case scenarios
      described here.
    </p>
    <section><h4>Consuming a Thing</h4>
    <ul>
      <li>
        <a>Consume a TD</a>, i.e. create a programmatic object from a
        <a>Thing Description</a> that exposes <a>WoT Interactions</a>:
        <ul>
          <li>Read the value of a <a>Property</a> or a set of properties.</li>
          <li>Set the value of a <a>Property</a> or a set of properties.</li>
          <li>Observe value changes of a <a>Property</a>.</li>
          <li>Invoke an <a>Action</a>.</li>
          <li>Observe WoT <a>Events</a> emitted by the <a>Thing</a>.</li>
          <li>
            Introspect the <a>Thing Description</a>.
          </li>
        </ul>
      </li>
    </ul>
    </section>

    <section><h4>Exposing a Thing</h4>
    <ul>
      <li>
        Exposing the <a>Thing</a> includes generating the protocol bindings in
        order to access lower level functionality.
      </li>
      <li>
        Create a local <a>Thing</a> to be exposed, based on <a>Thing Description</a>.
      </li>
      <li>
        The following use cases can be implemented before creating the
        <a>Thing</a> by editing the <a>Thing Description</a>:
        <ul>
          <li>Add a <a>Property</a> definition to the <a>Thing</a>.</li>
          <li>Remove a <a>Property</a> definition from the <a>Thing</a>.</li>
          <li>Add an <a>Action</a> definition to the <a>Thing</a>.</li>
          <li>Remove an <a>Action</a> definition from the <a>Thing</a>.</li>
          <li>Add a WoT <a>Event</a> definition to the <a>Thing</a>.</li>
          <li>Remove a WoT <a>Event</a> definition from the <a>Thing</a>.</li>
        </ul>
        <p class="ednote">
          After evaluating dynamic modifications to <a>Thing Descriptions</a>
          through several versions of this API, the editors concluded that the
          simplest way to represent these use cases is to take an existing
          <a>TD</a>, modify it (i.e. add or remove definitions) and then create
          a new <a>Thing</a> based on the modified <a>TD</a>.
        </p>
      </li>
      <li>
        Emit a WoT <a>Event</a>, i.e. notify all subscribed listeners.
      </li>
      <li>Register service handlers for external requests:
        <ul>
          <li>to retrieve a <a>Property</a> value;</li>
          <li>to update a <a>Property</a> value;</li>
          <li>to observe a <a>Property</a>;</li>
          <li>to unobserve a <a>Property</a>;</li>
          <li>
            to invoke an <a>Action</a>: take the parameters from the request, execute the defined action, and return the result;
          </li>
          <li>to subscribe to an <a>Event</a>;</li>
          <li>to unsubscribe from an <a>Event</a>.</li>
        </ul>
      </li>
    </ul>
    </section>

    <section><h4>Discovery</h4>
    <ul>
      <li>Discover <a>Thing</a>s in a network by sending a broadcast request.</li>
      <li>Discover <a>Thing</a>s running in the local <a>WoT Runtime</a>.</li>
      <li>Discover nearby <a>Thing</a>s, for instance connected by NFC or Bluetooth,
        or within a <a href="https://en.wikipedia.org/wiki/Geo-fence">geo-fence</a>.</li>
      <li>Discover <a>Thing</a>s by sending a discovery request to a given <a>TD Directory</a>.</li>
      <li>Discover <a>Thing</a>s filtered by filters defined on <a>Thing Description</a>s</li>
      <li>Discover <a>Thing</a>s filtered by semantic queries.</li>
      <li>Stop or suppress an ongoing discovery process.</li>
      <li>
          Optionally specify a timeout to the discovery process after which it is stopped/suppressed.
      </li>
    </ul>
    </section>
  </section>

  <section id="conformance">
    <p class="ednote">
    This specification used to be a Working Draft which was expected to become a W3C Recommendation. However, it is now a WG Note which contains informative statements only. Therefore we need to consider how to deal with the description within this Conformance section.</p>

    <p>
      This specification describes the conformance criteria for the following classes of [= user agent =] (<dfn>UA</dfn>).
    </p>
    <p>
      Due to requirements of small embedded implementations, splitting WoT client and server interfaces was needed. Then, discovery is a distributed application, but typical scenarios have been covered by a generic discovery API in this specification. This resulted in using 3 conformance classes for a <a>UA</a> that implements this API, one for client, one for server, and one for discovery. An application that uses this API can introspect for the presence of the <code>consume()</code>, <code>produce()</code> and <code>discover()</code> methods on the <a>WoT API object</a> in order to determine which conformance class the <a>UA</a> implements.
    </p>
    <dl>
      <dt>
        <dfn>WoT Consumer</dfn> <a>UA</a>
      </dt>
      <dd>
        <p>
          Implementations of this conformance class MUST implement the <code>{{ConsumedThing}}</code> interface and the <code>consume()</code> method on the <a>WoT API object</a>.
        </p>
      </dd>
      <dt>
        <dfn>WoT Producer</dfn> <a>UA</a>
      </dt>
      <dd>
        <p>
          Implementations of this conformance class MUST implement <code>{{ExposedThing}}</code> interface and the <code>produce()</code> method on the <a>WoT API object</a>.
        </p>
      </dd>
      <dt>
        <dfn>WoT Discovery</dfn> <a>UA</a>
      </dt>
      <dd>
        <p>
          Implementations of this conformance class MUST implement the
          <code><a>ThingDiscoveryProcess</a></code> interface, the
          <code>discover()</code> method, the <code>exploreDirectory()</code> method,
          and the <code>requestThingDescription()</code> method on the
          <a>WoT API object</a>.
        </p>
      </dd>
    </dl>
    <p>
      These conformance classes MAY be implemented in a single <a>UA</a>.
    </p>
    <p>
      This specification can be used for implementing the WoT Scripting API in multiple programming languages. The interface definitions are specified in [[!WEBIDL]].
    </p>
    <p>
      The <a>UA</a> may be implemented in the browser, or in a separate runtime environment, such as <a href="https://nodejs.org/en/">Node.js</a> or in small embedded runtimes.
    </p>
    <p>
      Implementations that use ECMAScript executed in a browser to implement the APIs defined in this document MUST implement them in a manner consistent with the ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]].
    </p>
    <p>
      Implementations that use TypeScript or ECMAScript in a runtime to implement the APIs defined in this document MUST implement them in a manner consistent with the TypeScript Bindings defined in the TypeScript specification [[!TYPESCRIPT]].
    </p>
  </section>

  <section> <h2>Terminology and conventions</h2>
    <p>
      The generic WoT terminology is defined in [[!WOT-ARCHITECTURE]]: <dfn data-lt="Things">Thing</dfn>, <dfn data-lt="Thing Descriptions">Thing Description</dfn> (in short <dfn>TD</dfn>), <dfn>Partial TD</dfn>, <dfn>Web of Things</dfn> (in short <b><i>WoT</i></b>),  <dfn>WoT Interface</dfn>, <dfn>Protocol Bindings</dfn>, <dfn>WoT Runtime</dfn>, <dfn data-lt="consume|consume a TD|consuming a TD">Consuming a Thing Description</dfn>, <dfn>TD Directory</dfn>, <dfn data-lt="Properties">Property</dfn>, <dfn data-lt="Actions">Action</dfn>, <dfn data-lt="Events|WoT-Event">Event</dfn>,
      <a data-cite="WOT-TD#dataschema">
        <dfn>DataSchema</dfn></a>, <a data-cite="WOT-TD#form"><dfn data-lt="Forms">Form</dfn></a>,
        <a data-cite="WOT-TD#securityscheme"><dfn>SecurityScheme</dfn></a>, <a data-cite="WOT-TD#nosecurityscheme"><dfn>NoSecurityScheme</dfn></a> etc.
    </p>
    <p>
      <dfn data-plurals="WoT Interactions">WoT Interaction</dfn> is a synonym for <a data-cite="WOT-ARCHITECTURE#dfn-interaction-affordance"><dfn>Interaction Affordance</dfn></a>.
      An <a>Interaction Affordance</a> (or shortly, affordance) is the term used in [[!WOT-TD]]
      when referring to <a>Thing</a> capabilities, as explained in
      <a href="https://github.com/w3c/wot-thing-description/issues/282">TD issue 282</a>.
      However, this term is not well understood outside the <a>TD</a> semantic context.
      Hence for the sake of readability, this document will use the previous term
      <a>WoT interaction</a> or, simply, <em>interaction</em> instead.
    </p>
    <p>
      <dfn>WoT network interface</dfn> synonym for <a>WoT Interface</a>.
    </p>
    <p>
      <dfn>JSON Schema</dfn> is defined in <a href="https://json-schema.org/specification.html">these specifications</a>.
    </p>
	<!--
    <p>
      The terms
      <dfn data-cite="!URL#concept-url">URL</dfn>,
      <dfn data-cite="!URL#concept-url-scheme">URL scheme</dfn>,
      <dfn data-cite="!URL#concept-url-host">URL host</dfn>,
      <dfn data-cite="!URL#concept-url-path">URL path</dfn>,
      <dfn data-cite="!URL#concept-url">URL record</dfn>,
      <dfn data-cite="!URL#url-parsing">parse a URL</dfn>,
      <dfn data-cite="!URL#absolute-url-string">absolute-URL string</dfn>,
      <dfn data-cite="!URL#path-absolute-url-string">path-absolute-URL string</dfn>,
      <dfn data-cite="!URL#concept-basic-url-parser">basic URL parser</dfn>
      are defined in [[!URL]].
    </p>
    <p>
      The terms
      <dfn data-cite="!MIMESNIFF#mime-type">MIME type</dfn>,
      <dfn data-cite="!MIMESNIFF#parsing-a-mime-type">Parsing a MIME type</dfn>,
      <dfn data-cite="!MIMESNIFF#serializing-a-mime-type">Serializing a MIME type</dfn>,
      <dfn data-cite="!MIMESNIFF#valid-mime-type">valid MIME type string</dfn>,
      <dfn data-cite="!MIMESNIFF#json-mime-type">JSON MIME type</dfn>
      are defined in [[!MIMESNIFF]].
    </p>
    <p>
      The terms
      <dfn data-cite="!ENCODING#utf-8">UTF-8 encoding</dfn>,
      <dfn data-cite="!ENCODING#utf-8-decode">UTF-8 decode</dfn>,
      <dfn data-cite="!ENCODING#encode">encode</dfn>,
      <dfn data-cite="!ENCODING#decode">decode</dfn>
      are defined in [[!ENCODING]].
    </p>
    <p>
      <dfn data-cite="!INFRA#string">string</dfn>,
      <dfn data-cite="!INFRA#parse-json-bytes-to-a-javascript-value">parse JSON from bytes</dfn> and
      <dfn data-cite="!INFRA#serialize-a-javascript-value-to-json-bytes">serialize JSON to bytes</dfn>,
      are defined in [[!INFRA]].
    </p>
	-->
    <p>
      <dfn data-cite="!ECMASCRIPT#sec-promise-objects">{{Promise}}</dfn>,
      <dfn data-cite="!ECMASCRIPT#sec-error-objects">Error</dfn>,
      <dfn data-cite="!ECMASCRIPT#sec-json-object">JSON</dfn>,
      <dfn data-cite="!ECMASCRIPT#sec-json.stringify">JSON.stringify</dfn>,
      <dfn data-cite="!ECMASCRIPT#sec-json.parse">JSON.parse</dfn>,
      <dfn data-cite="!ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal method</dfn> and
      <dfn data-cite="!ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal slot</dfn> are defined in [[!ECMASCRIPT]].
    </p>
	<!--
    <p>
      The terms
      <dfn data-cite="!HTML#browsing-context">browsing context</dfn>,
      <dfn data-cite="!HTML#top-level-browsing-context">top-level browsing context</dfn>,
      <dfn data-cite="!HTML#global-object">global object</dfn>,
      <dfn data-cite="!HTML#current-settings-object">current settings object</dfn>,
      executing algorithms <dfn data-cite="!HTML#in-parallel">in parallel</dfn>
       are defined in [[!HTML5]] and are used in the context of browser implementations.
    </p>
    <p>
      The term
      <a href="https://w3c.github.io/webappsec/specs/powerfulfeatures/#secure-context">
      <dfn>secure context</dfn></a> is defined in [[!WEBAPPSEC]].
    </p>
    <p>
      <dfn>IANA media type</dfn>s (formerly known as MIME types) are defined in
      <a href="http://tools.ietf.org/html/rfc2046">RFC2046</a>.
    </p>
    <p>
      The terms <dfn>hyperlink reference</dfn> and <dfn>relation type</dfn> are defined in [[!HTML5]] and <a href="https://tools.ietf.org/html/rfc8288">RFC8288</a>.
    </p>
	-->
  </section>

  <section data-cite="webidl">
    <h2>The <dfn>ThingDescription</dfn> type</h2>
    <pre class="idl">
      typedef object ThingDescription;
    </pre>

    <p>
      Represents a <a>Thing Description</a> (<a>TD</a>) as
      <a data-cite="WOT-TD#">defined</a> in
      [[!WOT-TD]]. It is expected to be
      a <a data-cite="infra#parse-json-bytes-to-a-javascript-value">parsed JSON object</a> that is validated using <a data-cite="WOT-TD#json-schema-for-validation">JSON Schema validation</a>.
    </p>
    <section> <h3> Requesting a Thing Description</h3>
      <p>
        Requesting a <a>TD</a> given a URL should be done with the
        <a href="#dom-wot-requestthingdescription">requestThingDescription()</a>
        method.
        Alternatively, external methods, such as the <a data-cite="fetch#fetch-api">Fetch API</a> or an HTTP client library, can be used.
      </p>
      <pre class="example" title="Requesting a Thing Description">
        try {
          const td = await requestThingDescription('https://tds.mythings.biz/sensor11');
          const thing = await WoT.consume(td);
          console.log("Thing name: " + thing.getThingDescription().title);
        } catch (err) {
          console.log("Requesting TD failed", err.message);
        }
      </pre>
    </section>

    <section> <h3>Expanding a Thing Description</h3>
      <p>
        Note that the [[[WOT-TD]]] specification allows using a shortened <a>Thing Description</a>
        by the means of <a data-cite="WOT-TD#sec-default-values">defaults</a> and requiring clients to expand them with default values specified in the
        [[[WOT-TD]]] specification for the properties that are not explicitly defined in a given
        <a>TD</a>.
      </p>
      <div>
        To <dfn>expand a TD</dfn> given |td:ThingDescription|, run the following steps:
        <ol>
          <li>
            For each item in the <a data-cite="WOT-TD#sec-default-values">TD default values</a> table from [[!WOT-TD]], if the term is not defined in |td|, add the term definition with the default value specified in [[!WOT-TD]].
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Validating a Thing Description</h3>
      <p>
        The [[!WOT-TD]] specification defines how a <a>TD</a> should be validated.
        Therefore, this API expects the {{ThingDescription}} objects be validated before used as parameters. This specification defines a basic <a>TD</a> validation as follows.
      </p>
      <div>
        To <dfn>validate a TD</dfn> given |td:ThingDescription|, run the following steps:
        <ol>
          <li>
            If <a data-cite="WOT-TD#json-schema-for-validation">JSON Schema
            validation</a> fails on |td|, [= exception/throw =] a {{"TypeError"}} and stop.
          </li>
        </ol>
        <p class="ednote" title="Handling default values">
          Additional steps may be added to fill the default values of mandatory fields.
        </p>
      </div>
    </section>
  </section>
  <section data-dfn-for="WOT" data-cite="webidl">
  <h2>The <dfn>WOT</dfn> namespace</dfn></h2>
  <p>
    Defines the <dfn>WoT API object</dfn> as a singleton and contains the API
    methods, grouped by conformance classes.
  </p>
  <pre class="idl">
    [SecureContext, Exposed=(Window,Worker)]
    namespace WOT {
      // methods defined in UA conformance classes
    };
  </pre>
  <section> <h3>The <dfn>consume()</dfn> method</h3>
    <pre class="idl">
      partial namespace WOT {
        Promise&lt;ConsumedThing&gt; consume(ThingDescription td);
      };
    </pre>
    <div>
      Belongs to the <a>WoT Consumer</a> conformance class. Expects an |td:ThingDescription| argument and returns a {{Promise}} that resolves with a {{ConsumedThing}} object that represents a client interface to operate with the <a>Thing</a>. The method MUST run the following steps:
      <ol>
        <li>
          Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
        </li>
        <li>
          If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
        </li>
        <li>
          Let |thing:ConsumedThing| be a new {{ConsumedThing}} object constructed from |td|.
        </li>
        <li>
          Set up the <a>WoT Interactions</a> based on introspecting <a>td</a> as explained in [[!WOT-TD]] and [[!WOT-PROTOCOL-BINDINGS]]. Make a request to the underlying platform to initialize the <a>Protocol Bindings</a>.
          <p class="ednote">
            Implementations encapsulate the complexity of how to use the
            <a>Protocol Bindings</a> for implementing <a>WoT interactions</a>.
            In the future elements of that could be standardized.
          </p>
        </li>
        <li>
          [=Resolve=] |promise| with |thing|.
        </li>
      </ol>
    </div>
  </section>

  <section> <h3>The <dfn>produce()</dfn> method</h3>
    <pre class="idl">
      typedef object ExposedThingInit;

      partial namespace WOT {
        Promise&lt;ExposedThing&gt; produce(ExposedThingInit init);
      };
    </pre>
    <div>
      Belongs to the <a>WoT Producer</a> conformance class. Expects a |init:ExposedThingInit| argument and returns a {{Promise}}
      that resolves with an {{ExposedThing}} object that extends {{ConsumedThing}} with a server interface,
      i.e. the ability to define request handlers. The |init:ExposedThingInit| object is an instance of the <a>ExposedThingInit</a> type.
      Specifically, an <a>ExposedThingInit</a> value is a dictionary used for the initialization of an <a>ExposedThing</a> and
      it represents a <a>Partial TD</a> as described in the [[!WOT-ARCHITECTURE]]. As such, it has the same
      structure of a <a>Thing Description</a> but it may omit some information.
      The method MUST run the following steps:
      <ol>
        <li>
          Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
        </li>
        <li>
          If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
        </li>
        <li>
          Let |thing:ExposedThing| be a new {{ExposedThing}} object constructed with |init|.
        </li>
        <li>
          [=Resolve=] |promise| with |thing|.
        </li>
      </ol>
    </div>
    <section>
      <h3>Expand an ExposedThingInit</h3>
      To <dfn>expand an ExposedThingInit</dfn> given |init:ExposedThingInit| and obtain a valid |td:ThingDescription| as a result, run the following steps:
      <ol class="algorithm">
        <li>
          Run <a>validate an ExposedThingInit</a> on |init|. If that fails,
          [= exception/throw =] {{SyntaxError}} and stop.</li>
        <li>
          Let |td| be the result of running [=map/clone=] given |init|.
        </li>
        <li>
          For each |scheme:SecurityScheme| in |td|.[<code>"securityDefinitions"</code>], make a request to the underlying platform to check if it is supported by at least one <a>Protocol Binding</a>. If not, then remove |scheme| from |td|.
        </li>
        <li>
          If |td|.[<code>"security"</code>] does not [=map/exist=] in |td|.[<code>"securityDefinitions"</code>], then remove <code>security</code> from |td|.
        </li>
        <li>For each |affordance| in |td|.properties, |td|.actions and |td|.events, run the following sub-steps:
          <ol>
            <li>For each |form:Form| in |affordance|.forms:
              <ol>
                <li>
                  If |form|.|contentType:string| is not recognized by the runtime as valid remove |contentType:string| from |form|.
                </li>
                <li>
                  If |form|.|href:URL| has an unknown schema, remove |href| from |form|.
                </li>
                <li>
                  If |form|.|href:URL| is absolute and its <code>authority</code> it is not recognized by the runtime as valid, remove |href| from |form|.
                </li>
                <li>
                  If |form|.|href:URL| is already in use by other <a>ExposedThings</a>, remove |href| from |form|.
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Search for missing required properties in |td| accordingly to
          <a data-cite="WOT-TD#json-schema-for-validation">TD JSON
            Schema</a>.
          <p class="ednote">The editors find this step vague. It will be improved or removed in the next iteration. </p>
        </li>
        <li>For each |missing| property run these sub-steps:
          <ol>
            <li>If |missing| is <code>title</code> generate a runtime unique name and assign to <code>title</code>.</li>
            <li>If |missing| is <code>@context</code> assign the latest supported Thing Description context URI.</li>
            <li>If |missing| is <code>instance</code> assign the string <code>1.0.0</code>.</li>
            <li>If |missing| is <code>forms</code> generate a list of <a>Forms</a> using the available <a>Protocol Bindings</a> and content types
              encoders. Then assign the obtained list to <code>forms</code>.</li>
            <li>If |missing| is <code>security</code> assign the label of the first supported <a>SecurityScheme</a> in <code>securityDefinitions</code> field.
            If no <a>SecurityScheme</a> is found generate a <a>NoSecurityScheme</a> called <code>nosec</code> and assign the string <code>nosec</code>
          to <code>security</code>.
          <p class="issue">The discussion about how to properly generate a value for <code>security</code> is still open.
            See issue <a href="https://github.com/w3c/wot-scripting-api/issues/299">#299</a> </p>
          </li>
            <li>If |missing| is <code>href</code> define |formStub| as the partial <a>Form</a> that does not have <code>href</code>. Generate a valid |url:URL| using the first <a>Protocol Binding</a>
              that satisfy the requirements of |formStub|. Assign |url| to <code>href</code>. If not <a>Protocol Binding</a> can be found remove |formStub| from |td|. </li>
            <li>Add |missing| to |td| with |value| as value</li>
          </ol>
        </li>
        <li>Run <a>validate a TD</a> on |td|. If that fails re-[= exception/throw =] the error and stop</li>
        <li>Return |td|</li>
      </ol>
    </section>
    <section>
      <h3>Validating an ExposedThingInit</h3>
      To <dfn>validate an ExposedThingInit</dfn> given |init:ExposedThingInit|, run the following steps:
      <ol  class="algorithm">
        <li>
          Parse <a data-cite="WOT-TD#json-schema-for-validation">TD JSON
            Schema</a>
          and load it in object called |exposedThingInitSchema:object|
        </li>
        <li>let |optional:Array| be a list containing the following strings: <code>title</code>, <code>@context</code>,
        <code>instance</code>, <code>forms</code>, <code>security</code>, and <code>href</code>. </li>
        <li>
          For each property and sub-property |key| in |exposedThingInitSchema| equals to <code>required</code> execute the following steps:
          <ol>
            <li>if |key| |value| is an <code>Array</code> then remove all its elements equal to the elements in |optional|</li>
            <li>if |key| |value| is a <code>string</code> then if |value| is equal to one of the elements in |optional| remove |key| from |exposedThingInitSchema|</li>
          </ol>
        </li>
        <li>Return the result of <a>validating an object with JSON Schema</a> given |init| and |exposedThingInitSchema|.
          <p class="ednote">The <dfn>validating an object with JSON Schema</dfn> steps are still under discussion.
            Currently this specification reference to the validation process of JSONSchema. Please
            follow this <a href="https://json-schema.org/draft/2019-09/json-schema-validation.html">document</a>
            when validating |init| with |exposedThingInitSchema|. Notice that the working group is evaluating an alternative formal approach.
          </p>
        </li>
      </ol>
    </section>
  </section>

  <section> <h3>The <dfn>discover()</dfn> method</h3>
    <pre class="idl">
      partial namespace WOT {
        Promise&lt;ThingDiscoveryProcess&gt; discover(optional ThingFilter filter = {});
      };
    </pre>
    <div>
      Belongs to the <a>WoT Discovery</a> conformance class. Starts the discovery process that will provide {{ThingDescription}} objects for <a>Thing Description</a>s that match an optional |filter:ThingFilter| argument of type {{ThingFilter}}. The method MUST run the following steps:
      <ol>
        <li>
          Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
        </li>
        <li>
          If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
        </li>
        <li>
          If discovery is not supported by the implementation, [=reject=] |promise|
          with {{NotSupportedError}} and stop.
        </li>
        <li>
          Let |discovery:ThingDiscoveryProcess| be a new {{ThingDiscoveryProcess}} object.
        </li>
        <li>
          Set |discovery|.{{ThingDiscoveryProcess/[[filter]]}} to |filter:ThingFilter|.
        </li>
        <li>
          Set |discovery|.{{ThingDiscoveryProcess/[[url]]}} to `undefined`.
        </li>
        <li>
          If filters in general are not supported by the implementation and
          |filter| is not `undefined` or `null`, [=reject=] |promise|
          with {{NotSupportedError}} and stop.
        </li>
        <li>
          If discovery cannot be started by the underlying platform,
          [=reject=] |promise| with {{OperationError}} and stop.
        </li>
        <li>
          Request the underlying platform to start the <a>discovery process</a>
          by any means supported and provisioned in the <a>WoT Runtime</a> for which
          the script has access to, passing |discovery| to it.
        </li>
        <li>
          [=Resolve=] |promise| with |discovery|.
        </li>
      </ol>
    </div>
  </section>

  <section> <h3>The <dfn>exploreDirectory()</dfn> method</h3>
    <pre class="idl">
      partial namespace WOT {
        Promise&lt;ThingDiscoveryProcess&gt; exploreDirectory(USVString url,
            optional ThingFilter filter = {});
      };
    </pre>
    <div>
      Belongs to the <a>WoT Discovery</a> conformance class. Starts the discovery process that given a <a>TD Directory</a> URL, will provide {{ThingDescription}} objects for <a>Thing Description</a>s that match an optional |filter:ThingFilter| argument of type {{ThingFilter}}. The method MUST run the following steps:
      <ol>
        <li>
          Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
        </li>
        <li>
          If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
        </li>
        <li>
          If directory discovery is not supported by the implementation, [=reject=] |promise|
          with {{NotSupportedError}} and stop.
        </li>
        <li>
          Let |discovery:ThingDiscoveryProcess| be a new {{ThingDiscoveryProcess}} object.
        </li>
        <li>
          Set |discovery|.{{ThingDiscoveryProcess/[[url]]}} to |url:USVString|.
        </li>
        <li>
          Set |discovery|.{{ThingDiscoveryProcess/[[filter]]}} to |filter:ThingFilter|.
        </li>
        <li>
          Request the underlying platform to start the directory discovery process.
          <p class="note">
            This is a placeholder for more details in the discovery algorithm.
            Implementations should follow the procedures described in the
            [[WOT-DISCOVERY]] and [WOT-PROTOCOL-BINDINGS] specifications.
            Some normative steps are indicated below.
          </p>
          <ol>
            <li>
              If |url| is not a <a>TD Directory</a> or if the underlying
              implementation cannot support the <a>Protocol Binding</a>
              indicated by |url|, [=reject=] |promise|
              with {{NotSupportedError}} and terminate these steps.
            </li>
            <li>
              If filters in general are not supported by the implementation and
              |filter| is not `undefined` or `null`, [=reject=] |promise|
              with {{NotSupportedError}} and stop.
            </li>
            <li>
              Run the <a>discovery process</a> given |discovery|.
              <p class="note">
                From this point on, errors are recorded only on
                {{ThingDiscoveryProcess/error}}, but don't affect |promise| any longer.
              </p>
            </li>
          </ol>
        </li>
        <li>
          [=Resolve=] |promise| with |discovery|.
        </li>
      </ol>
    </div>
  </section>

  <section> <h3>The <dfn>requestThingDescription()</dfn> method</h3>
    <pre class="idl">
      partial namespace WOT {
        Promise&lt;ThingDescription&gt; requestThingDescription(USVString url);
      };
    </pre>
    <div>
      Belongs to the <a>WoT Discovery</a> conformance class.
      Requests a <a>Thing Description</a> from the given URL.
      The method MUST run the following steps:
      <ol>
        <li>
          Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
        </li>
        <li>
          If invoking this method is not allowed for the current scripting
          context for security reasons, [=reject=] |promise| with a {{SecurityError}}
          and stop.
        </li>
        <li>
          If requesting a <a>Thing Description</a> is not supported by the
          implementation, [=reject=] |promise| with {{NotSupportedError}} and
          stop.
        </li>
        <li>
          Let |td:ThingDescription| be the result of making a request to the underlying
          platform to retrieve the <a>Thing Description</a> using the
            <a>Protocol Binding</a> specified by |url|.
          If retrieving |td| fails, [=reject=] |promise| with {{NotFoundError}} and
          stop.
        </li>
        <li>
          [=Resolve=] |promise| with |td|.
        </li>
      </ol>
    </div>
  </section>

  </section> <!-- WoT -->

  <section data-cite="webidl"> <h2>Handling interaction data</h2>
  <p>
    As specified in the [[[WOT-TD]]] specification, <a>WoT interactions</a> extend <a>DataSchema</a>
    and include a number of possible <a>Form</a>s, out of which one is selected
    for the interaction. The
    <a data-cite="WOT-TD#form">
    Form</a> contains a `contentType` to describe the data.
    For certain content types, a <a>DataSchema</a> is defined, based on
    <a>JSON Schema</a>, making possible to represent these contents as
    JavaScript types and eventually set range constraints on the data.
  </p>

  <section data-dfn-for="InteractionInput">
    <h2>The <dfn>InteractionInput</dfn> type</h2>
    <pre class="idl">
      typedef any DataSchemaValue;
      typedef (ReadableStream or DataSchemaValue) InteractionInput;
    </pre>
    <p>
      Belongs to the <a>WoT Consumer</a> conformance class and represents the
      <a>WoT Interaction</a> data provided by application scripts to the UA.
    </p>
    <p>
      <dfn>DataSchemaValue</dfn> is an
      <a data-cite="ECMASCRIPT#sec-ecmascript-data-types-and-values">ECMAScript value</a> that is accepted for <a>DataSchema</a> defined in [[WoT-TD]].
	  The possible values MUST be of type <a data-cite="ECMASCRIPT#sec-ecmascript-language-types-null-type">null</a>, <a data-cite="ECMASCRIPT#sec-ecmascript-language-types-boolean-type">boolean</a>, <a data-cite="ECMASCRIPT#sec-ecmascript-language-types-number-type">number</a>, <a data-cite="ECMASCRIPT#sec-ecmascript-language-types-string-type">string</a>, <a data-cite="ECMASCRIPT#sec-array-objects">array</a>, or <a data-cite="ECMASCRIPT#sec-object-type">object</a>.
    </p>
    <p>
      {{ReadableStream}} is meant to be used for <a>WoT Interactions</a> that
      don't have a <a>DataSchema</a> in the <a>Thing Description</a>, only a
      {{Form}}'s `contentType` that can be represented by a stream.
    </p>
    <p>
      In practice, any
      <a data-cite="ECMASCRIPT#sec-ecmascript-data-types-and-values">ECMAScript value</a> may be used for <a>WoT Interactions</a> that have a
      <a>DataSchema</a> defined in the <a>Thing Description</a>,
      or which can be mapped by implementations to the {{Form}}'s `contentType`
      defined in the <a>Thing Description</a>.
    </p>
    <p>
      The algorithms in this document specify how exactly input data is used in
      <a>WoT Interactions</a>.
    </p>
  </section>

  <section data-dfn-for="InteractionOutput">
    <h2>The <dfn>InteractionOutput</dfn> interface</h2>
    <p>
      Belongs to the <a>WoT Consumer</a> conformance class.
      An {{InteractionOutput}} object is always created by the implementations
      and exposes the data returned from <a>WoT Interactions</a> to application
      scripts.
    </p>
    <p>
      This interface exposes a convenience function which should cover
      the vast majority of IoT use cases: the
      <a href="#the-value-function">value()</a> function. Its implementation
      will inspect the data, parse it if adheres to a <a>DataSchema</a>, or
      otherwise fail early, leaving the underlying stream undisturbed so
      that application scripts could attempt reading the stream themselves, or
      handling the data as {{ArrayBuffer}}.
    </p>
    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface InteractionOutput {
        readonly attribute ReadableStream? data;
        readonly attribute boolean dataUsed;
        readonly attribute Form? form;
        readonly attribute DataSchema? schema;
        Promise&lt;ArrayBuffer&gt; arrayBuffer();
        Promise&lt;DataSchemaValue&gt; value();
      };
    </pre>
    <p>
      The <dfn>data</dfn> property represents the raw payload in
      <a>WoT Interactions</a> as a {{ReadableStream}}, initially `null`.
    </p>
    <p>
      The <dfn>dataUsed</dfn> property tells whether the data stream has
      been <a data-cite="streams#is-readable-stream-disturbed">

      disturbed</a>. Initially `false`.
    </p>
    <p>
      The <dfn>form</dfn> attribute represents the <a>Form</a> selected from
      the <a>Thing Description</a> for this <a>WoT Interaction</a>,
      initially `null`.
    </p>
    <p>
      The <dfn>schema</dfn> attribute represents the <a>DataSchema</a>
      (defined in [[WoT-TD]]) of the payload as a {{JSON}} object, initially `null`.
    </p>
    <p>
      The <dfn data-lt="value">[[\value]]</dfn> internal slot represents the parsed value of
      the <a>WoT Interaction</a>, initially `undefined` (note that `null` is a
      valid value).
    </p>
    <section><h3>The <dfn>value()</dfn> function</h3>
      Parses the data returned by the <a>WoT Interaction</a> and returns a
      value with the type described by the interaction <a>DataSchema</a>
      if that exists, or by the `contentType` of the interaction <a>Form</a>. The method MUST run the following steps:
      <ol>
        <li>
          Return a {{Promise}} |promise:Promise| and execute the next steps
          [=in parallel=].
        </li>
        <li>
          If |this|.<a>[[\value]]</a> is not `undefined`, [=resolve=] |promise| with that value and stop.
        </li>
        <li>
          If |this|.|data| is not a {{ReadableStream}} or if
          |dataUsed| is `true`, or if |form| is not an {{object}} or if |schema|
          is `null` or `undefined`, then
          [=reject=] |promise| with {{NotReadableError}} and stop.
        </li>
        <li>
          If |form|.|contentType| is not `application/json` and if a mapping is
          not available in the <a>Protocol Bindings</a> from |form|.|contentType|
          to [[!JSON-SCHEMA]], [=reject=] |promise| with {{NotSupportedError}} and
          stop.
        </li>
        <li>
          Let |reader| be the result of
          <a data-cite="streams#readablestream-get-a-reader">
          getting a reader</a> from |data|. If that threw an exception, [=reject=]
          |promise| with that exception and stop.
        </li>
        <li>
          Let |bytes| be the result of <a data-cite="streams#readablestream-get-a-reader">
          reading all bytes</a> from |data| with |reader|.
        </li>
        <li>
          Set |dataUsed| to `true`.
        </li>
        <li>
          If |form|.|contentType| is not `application/json` and if a mapping is
          available in the <a>Protocol Bindings</a> from |form|.|contentType|
          to [[!JSON-SCHEMA]], transform |bytes| with that mapping.
        </li>
        <li>
          Let |json| be the result of running <a>parse JSON from bytes</a> on
          |bytes|. If that throws, [=reject=] |promise| with that exception and
          stop.
        </li>
        <li>
          Set <a>[[\value]]</a> to the result of running <a>check data schema</a>
          on |json| and |schema|. If that throws, [=reject=] |promise| with that
          exception and stop.
        </li>
        <li>
          [=Resolve=] |promise| with <a>[[\value]]</a>.
        </li>
      </ol>
    </section>

    <section><h3>The  <dfn>arrayBuffer()</dfn> function</h3>
      When invoked, MUST run the following steps:
      <ol>
        <li>
          Return a {{Promise}} |promise:Promise| and execute the next steps
          [=in parallel=].
        </li>
        <li>
          If |data| is not {{ReadableStream}} or if |dataUsed| is `true`,
          [=reject=] |promise| with {{NotReadableError}} and stop.
        </li>
        <li>
          Let |reader| be the result of
          <a data-cite="streams#readablestream-get-a-reader">
          getting a reader</a> from |data|. If that threw an exception, [=reject=]
          |promise| with that exception and stop.
        </li>
        <li>
          Let |bytes| be the result of <a data-cite="streams#readablestream-get-a-reader">
          reading all bytes</a> from |data| with |reader|.
        </li>
        <li>
          Set |dataUsed| to `true`.
        </li>
        <li>
          Let |arrayBuffer| be a new {{ArrayBuffer}} whose contents are |bytes|.
          If that throws, [=reject=] |promise| with that exception and stop.
        </li>
        <li>
          [=Resolve=] |promise| with |arrayBuffer|.
        </li>
      </ol>
    </section>

    <section><h3>The <dfn>check data schema</dfn> algorithm</h3>
      To run the <a>check data schema</a> steps on |payload| and |schema:object|,
      <ol>
        <li>
          If |schema| is `null` or `undefined`, return `undefined`.
        </li>
        <li>
          If |schema|.|const| is not |undefined| and |schema|.|const| does not equal |payload|, throw {{TypeError}} and stop.
        </li>
        <li>
          If |schema|.|enum| is not |undefined| and none of the elements in
          |schema|.|enum| equal |payload|, throw {{TypeError}} and stop.
        </li>
        <li>
          Let |oneOf| be |schema|.|oneOf|.
          If |oneOf| is not |undefined|,
          <ol>
            <li>
              For each |subSchema| in |oneOf|, run the <a>check data schema</a>
              steps on |payload| and |subSchema|.
            </li>
            <li>
              If none or more than one of these runs do not throw, throw
              {{TypeError}} and stop.
            </li>
          </ol>
        </li>
        <li>
          Let |type| be |schema|.|type|.
        </li>
        <li>
          If |type| is `"null"` and if |payload| is not `null`,
          throw {{TypeError}} and stop, otherwise return `null`.
        </li>
        <li>
          If |type| is `"boolean"` and |payload| is a falsy value or its byte
          length is 0, return `false`, otherwise return `true`.
        </li>
        <li>
          If |type| is `"integer"` or `"number"`,
          <ol>
            <li>
              If |payload| is not a number, throw {{TypeError}} and stop.
            </li>
            <li>
              If |form|.|minimum| is defined and |payload| is smaller, or if |form|.|maximum| is defined and |payload| is bigger, throw a {{RangeError}} and stop.
            </li>
          </ol>
        </li>
        <li>
          If |type| is `"string"`, return |payload|.
        </li>
        <li>
          If |type| is `"array"`, run these sub-steps:
          <ol>
            <li>
              If |payload| is not an array, throw {{TypeError}} and stop.
            </li>
            <li>
              If |form|.|minItems| is defined and |payload|.|length| is
              less than that, or if |form|.|maxItems| is defined and
              |payload|.|length| is more than that, throw {{RangeError}} and stop.
            </li>
            <li>
              Let |payload| be an array of items obtained by running the
              <a>check data schema</a> steps on each element |item| of |payload|
              and |schema|.|items|.
              If this throws at any stage, re-throw that exception and stop.
            </li>
          </ol>
        </li>
        <li>
          If |type| is `"object"`, run these sub-steps:
          <ol>
            <li>
              If |payload| or |schema|.|properties| is not an {{object}},
              throw {{TypeError}} and stop.
            </li>
            <li>
              For each |key| in |payload|:
              <ol>
                <li>Let |prop| be |payload|[|key|].</li>
                <li>
                  Let |propSchema| be |interaction|.|properties|[|key|].
                </li>
                <li>
                  Let |prop| be the result of running the
                  <a>check data schema</a> steps on |prop| and |propSchema|.
                  If this throws, re-throw that exception and stop.
                </li>
              </ol>
            </li>
            <li>
              Let |required| be |schema|.|required| if that is an array
              or an empty array otherwise.
            </li>
            <li>
              For each |key| in |required|, if |key| is not present in |payload|,
              throw {{SyntaxError}} and stop.
            </li>
          </ol>
        </li>
        <li>
          Return |payload|.
        </li>
      </ol>
    </section>

    <section><h3>The <dfn>create interaction request</dfn> algorithm</h3>
      For a given <a>ConsumedThing</a> object |thing:ConsumedThing|, in order to
      <a>create interaction request</a> given a |source: InteractionInput|, |form:Form| and
      |schema:object|, run these steps:
      <ol>
        <li>
          Let |idata| be a new an {{InteractionOutput}} object.
        </li>
        <li>
           Set |idata|.|form| to |form|, set |idata|.|schema| to |schema|, set |idata.|data| to `null` and set |idata|.{{InteractionOutput/[[value]]}} to `undefined`.
        </li>
        <li>
          If |source| is a {{ReadableStream}} object, let |idata|.|data| be
          |source|, return |idata| and stop.
        </li>
        <li>
          If |schema| and its |type| are defined and not `null`, run these sub-steps:
          <ol>
            <li>
              If |type| is `"null"` and |source| is not `"null"`,
              throw {{TypeError}} and stop.
            </li>
            <li>
              If |type| is `"boolean"` and |source| is a falsy value, set
              |idata|.{{InteractionOutput/[[value]]}} to `false`, otherwise set it to `true`.
            </li>
            <li>
              If |type| is `"integer"` or `"number"` and |source| is not a number,
              or if |form|.|minimum| is defined and |source| is smaller,
              or if |form|.|maximum| is defined and |source| is bigger,
              throw {{RangeError}} and stop.
            </li>
            <li>
              If |type| is `"string"` and |source| is not a string, let
              |idata|.{{InteractionOutput/[[value]]}} be the result of running
              <a>serialize JSON to bytes</a> given |source|.
              If that is failure, throw {{SyntaxError}} and stop.
            </li>
            <li>
              If |type| is `"array"`, run these sub-steps:
              <ol>
                <li>
                  If |source| is not an array, throw a {{TypeError}} and stop.
                </li>
                <li>
                  Let |length| be the length of |source|.
                </li>
                <li>
                  If |form|.|minItems| is defined and |length| is less than
                  that, or if |form|.|maxItems| is defined and |length| is
                  more than that, throw {{RangeError}} and stop.
                </li>
                <li>
                  For each |item| in |source|, let |itemschema| be |schema|.|items|
                  and let |item| be the result of running the
                  <a>create interaction request</a> steps given |item|, |form| and
                  |itemschema|.
                  If this throws, re-throw that exception and stop.
                </li>
                <li>
                  Set |data|.{{InteractionOutput/[[value]]}} to |source|.
                </li>
              </ol>
            </li>
            <li>
              If |type| is `"object"`, run these sub-steps:
              <ol>
                <li>
                  If |source| is not an object, throw {{TypeError}} and stop.
                </li>
                <li>
                  If |schema|.|properties| is not an object,
                  throw {{TypeError}} and stop.
                </li>
                <li>
                  For each |key| in |source|,
                  <ol>
                    <li>Let |value| be |source|[|key|].</li>
                    <li>Let |propschema| be |properties|.|interactions|[|key|].</li>
                    <li>
                      Let |value| be the result of running the
                      <a>create interaction request</a> steps on |value|, |form|
                      and |propschema|.
                      If this throws, re-throw that exception and stop.
                    </li>
                  </ol>
                </li>
                <li>
                  If |schema|.|required| is an array, for each |item| in |required|
                  check if |item| is a property name in |source|. If an |item| is
                  not found in |source|, throw {{SyntaxError}} and stop.
                </li>
                <li>
                  Set |data|.{{InteractionOutput/[[value]]}} to |source|.
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          Set |idata|.|data| to a new {{ReadableStream}} created from
          |idata|.{{InteractionOutput/[[value]]}} <a>internal slot</a> as its
          <a data-cite="streams#underlying-source">underlying source</a>.
        </li>
        <li>
          Return |idata|.
        </li>
      </ol>
    </section>

    <section><h3>The <dfn>parse interaction response</dfn> algorithm</h3>
      For a given <a>ConsumedThing</a> object |thing:ConsumedThing|, in order to
      <a>parse interaction response</a> given |response|, |form:Form| and
      |schema:object|, run these steps:
      <ol>
        <li>
          Let |result| be a new {{InteractionOutput}} object.
        </li>
        <li>
          Let |result|.|schema| be |schema|.
        </li>
        <li>
          Let |result|.|form| be |form|.
        </li>
        <li>
          Let |result|.|data| be a new {{ReadableStream}} with the payload data
          of |response| as its
          <a data-cite="streams#underlying-source">
          underlying source</a>.
        </li>
        <li>
          Let |result|.|dataUsed| be `false`.
        </li>
        <li>
          Return |result|.
        </li>
      </ol>
    </section>
  </section>
  <section> <h3>Using {{InteractionInput}} and {{InteractionOutput}}</h3>
    <p>
      As illustrated in the next pictures, the {{InteractionOutput}} interface
      is used every time implementations provide data to scripts, while
      {{InteractionInput}} is used when the scripts pass data to the
      implementation.
    </p>
    <figure id="scripting-read">
      <img src="images/scripting-read-data.png"
                style="width:100%;"
                title="Reading data"/>
      <figcaption>Data structures used when reading data</figcaption>
    </figure>
    <p>
      When a {{ConsumedThing}} reads data, it receives it from the implementation
      as an {{InteractionOutput}} object.
    </p>
    <p>
      An {{ExposedThing}} <a href="#the-propertyreadhandler-callback">
      read handler</a> provides the read data to the implementation as
      {{InteractionInput}}.
    </p>

    <figure id="scripting-write">
      <img src="images/scripting-write-data.png"
                style="width:100%;"
                title="Writing data"/>
      <figcaption>Data structures used when writing data</figcaption>
    </figure>
    <p>
      When a {{ConsumedThing}} writes data, it provides it to the implementation
      as {{InteractionInput}}.
    </p>
    <p>
      An {{ExposedThing}} <a href="#the-propertywritehandler-callback">
      write handler</a> receives data from to implementation as
      an {{InteractionOutput}} object.
    </p>

    <figure id="scripting-action">
      <img src="images/scripting-action-data.png"
                style="width:100%;"
                title="Invoking action"/>
      <figcaption>Data structures used when invoking an Action</figcaption>
    </figure>
    <p>
      When a {{ConsumedThing}} invokes an <a>Action</a>, it provides the
      parameters as {{InteractionInput}} and receives the output of the
      <a>Action</a> as an {{InteractionOutput}} object.
    </p>
    <p>
      An {{ExposedThing}} <a href="#the-actionhandler-callback">
      action handler</a> receives arguments from the implementation as
      an {{InteractionOutput}} object and provides <a>Action</a> output as
      {{InteractionInput}} to the implementation.
    </p>
  </section>

  <section> <h3>Error handling</h3>
    <p>
      The algorithms in this API define the errors to be reported to application
      scripts.
    </p>
    <p>
      The errors reported to the other communication end are mapped and
      encapsulated by the <a>Protocol Bindings</a>.
    </p>
    <figure id="scripting-error-handling">
      <img src="images/scripting-error-handling.png"
                style="width:100%;"
                title="Error handling"/>
      <figcaption>Error handling in WoT interactions</figcaption>
    </figure>
    <p class="ednote">
      This topic is still being discussed in
      <a href="https://github.com/w3c/wot-scripting-api/issues/200">Issue #200</a>.
      A standardized error mapping would be needed in order to ensure consistency
      in mapping script errors to protocol errors and vice versa. In particular,
      when algorithms say "error received from the <a>Protocol Bindings</a>",
      that will be factored out as an explicit error mapping algorithm. Currently,
      that is encapsulated by implementations.
    </p>
  </section>

  </section> <!-- Handling interaction data -->

  <section data-cite="webidl" data-dfn-for="ConsumedThing">
    <h2>The <dfn>ConsumedThing</dfn> interface</h2>
    <p>
      Represents a client API to operate a <a>Thing</a>. Belongs to the
      <a>WoT Consumer</a> conformance class.
    </p>
    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ConsumedThing {
        Promise&lt;InteractionOutput&gt; readProperty(DOMString propertyName,
                                    optional InteractionOptions options = {});
        Promise&lt;PropertyReadMap&gt; readAllProperties(
                                    optional InteractionOptions options = {});
        Promise&lt;PropertyReadMap&gt; readMultipleProperties(
                                    sequence&lt;DOMString&gt; propertyNames,
                                    optional InteractionOptions options = {});
        Promise&lt;undefined&gt; writeProperty(DOMString propertyName,
                                    InteractionInput value,
                                    optional InteractionOptions options = {});
        Promise&lt;undefined&gt; writeMultipleProperties(
                                    PropertyWriteMap valueMap,
                                    optional InteractionOptions options = {});
        /*Promise&lt;undefined&gt; writeAllProperties(
                                    PropertyWriteMap valueMap,
                                    optional InteractionOptions options = {});*/
        Promise&lt;InteractionOutput&gt; invokeAction(DOMString actionName,
                                    optional InteractionInput params = {},
                                    optional InteractionOptions options = {});
        Promise&lt;Subscription&gt; observeProperty(DOMString name,
                                    InteractionListener listener,
                                    optional ErrorListener onerror,
                                    optional InteractionOptions options = {});
        Promise&lt;Subscription&gt; subscribeEvent(DOMString name,
                                    InteractionListener listener,
                                    optional ErrorListener onerror,
                                    optional InteractionOptions options = {});
        ThingDescription getThingDescription();
      };

      dictionary InteractionOptions {
        unsigned long formIndex;
        object uriVariables;
        any data;
      };

      [SecureContext, Exposed=(Window,Worker)]
      interface Subscription {
        readonly attribute boolean active;
        Promise&lt;undefined&gt; stop(optional InteractionOptions options = {});
      };

      [SecureContext, Exposed=(Window,Worker)]
      interface PropertyReadMap {
        readonly maplike&lt;DOMString, InteractionOutput&gt;;
      };

      [SecureContext, Exposed=(Window,Worker)]
      interface PropertyWriteMap {
        readonly maplike&lt;DOMString, InteractionInput&gt;;
      };

      callback InteractionListener = undefined(InteractionOutput data);
      callback ErrorListener = undefined(Error error);
    </pre>
    <p class="ednote" title="Where is the writeAllProperties method?">
      The <code>writeAllProperties()</code> method is still under discussion.
      Meanwhile, use the <code>writeMultipleProperties()</code> method instead.
    </p>
    <section>
      <h4>Internal slots for {{ConsumedThing}}</h4>
      <p>
        A {{ConsumedThing}} object has the following <a>internal slots</a>:
      </p>
      <table class="simple">
        <thead>
         <tr>
          <th>Internal Slot</th>
          <th>Initial value</th>
          <th>Description (<em>non-normative</em>)</th>
         </tr>
        </thead>
        <tbody data-link-for="ConsumedThing">
         <tr>
          <td><dfn>[[\td]]</dfn></td>
          <td>`null`</td>
          <td>The <a>Thing Description</a> of the {{ConsumedThing}}.</td>
         </tr>
        <tr>
          <td><dfn>[[\activeSubscriptions]]</dfn></td>
          <td>`{}`</td>
          <td>
            An [=ordered map=] [=map/keyed=] on a [=string=] name representing the <a>Event</a> and [=map/value=] is a {{Subscription}} object.
          </td>
        </tr>
        <tr>
          <td><dfn>[[\activeObservations]]</dfn></td>
          <td>`{}`</td>
          <td>
            An [=ordered map=] [=map/keyed=] on a [=string=] name representing a <a>Property</a> and [=map/value=] is a {{Subscription}} object.
          </td>
        </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h4>Creating <code>ConsumedThing</code></h4>
      <p>
        After <a href="#requesting-a-thing-description">requesting</a> a
        <a>Thing Description</a> as a JSON object, one can create a
        {{ConsumedThing}} object.
      </p>
      <div>
        To create {{ConsumedThing}} with the {{ThingDescription}}
        |td:ThingDescription|, run the following steps:
        <ol>
          <li>
            Run the <a>validate a TD</a> steps on |td|. If that fails,
            [= exception/throw =] {{SyntaxError}} and stop.
          </li>
          <li>
            Run the <a>expand a TD</a> steps on |td|. If that fails, re-[= exception/throw =] the error and stop.
          </li>
          <li>
            Let |thing:ConsumedThing| be a new {{ConsumedThing}} object.
          </li>
          <li>
            Set the <a>internal slot</a> {{ConsumedThing/[[td]]}} of |thing| to |td|.
          </li>
          <li>
            Return |thing|.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>The <dfn>getThingDescription()</dfn> method</h3>
      <p>
        Returns the {{ConsumedThing/[[td]]}} of the {{ConsumedThing}} object
        that represents the <a>Thing Description</a> of the {{ConsumedThing}}.
        Applications may consult the <a>Thing</a> metadata stored in {{ConsumedThing/[[td]]}} in
        order to introspect its capabilities before interacting with it.
      </p>
    </section>

    <section>
      <h3>The <dfn>readProperty()</dfn> method</h3>
      <div>
        Reads a <a>Property</a> value. Takes as arguments |propertyName:string|
        and optionally |options:InteractionOptions|.
        It returns a {{Promise}} that resolves with a <a>Property</a> value
        represented as an {{InteractionOutput}} object or rejects on error.
        The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps
            [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting
            context for security reasons, [=reject=] |promise| with a
            {{SecurityError}} and stop.
          </li>
          <li>
            Let |interaction| be {{ConsumedThing/[[td]]}}.|properties|.|propertyName|.
          </li>
          <li>
            If |interaction| is  `undefined`, [=reject=] |promise| with a {{NotFoundError}}
            and stop.
          </li>
          <li>
            If |option|.|formIndex| is defined, let |form| be the
            <a>Form</a> associated with |formIndex| in |interaction|.|forms|
            array, otherwise let |form| be a <a>Form</a> in
            |interaction|.|forms| whose |op| is `readproperty`, selected by
            the implementation.
          </li>
          <li>
            If |form| is failure, [=reject=] |promise| with a {{SyntaxError}} and
            stop.
          </li>
          <li>
            Make a request to the underlying platform (via the
            <a>Protocol Bindings</a>) to retrieve the value of the |propertyName| <a>Property</a>
            using |form| and the optional URI templates given in |options|.|uriVariables|.
          </li>
          <li>
            If the request fails, [=reject=] |promise| with the error received from the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |response| be the response received to the request.
          </li>
          <li>
            Let |data| be the result of running <a>parse interaction response</a>
            on |response|, |form| and |interaction|.
            If that fails, [=reject=] |promise| with a {{SyntaxError}} and stop.
          </li>
          <li>
            [=Resolve=] |promise| with |data|.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>The <dfn>readMultipleProperties()</dfn> method</h3>
      <div>
        Reads multiple <a>Property</a> values with one request.
        Takes as arguments |propertyNames: string sequence| and optionally
        |options:InteractionOptions|.
        It returns a {{Promise}} that resolves with a {{PropertyReadMap}} object
        that maps keys from |propertyNames| to values returned by this algorithm.
        The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            If |option|.|formIndex| is defined, let |form| be the
            <a>Form</a> associated with |formIndex| in the {{ConsumedThing/[[td]]}}.|forms| array, otherwise let |form| be the <a>Form</a> in {{ConsumedThing/[[td]]}}.|forms| array whose |op| is `readmultipleproperties`, as selected by the implementation.
          </li>
          <li>
            If |form| is failure, [=reject=] |promise| with a {{SyntaxError}} and stop.
          </li>
          <li>
            Let |result:object| be an object and for each string |name:string| in |propertyNames| add a property with key |name| and the value `null`.
          </li>
          <li>
            Make a request to the underlying platform (via the <a>Protocol Bindings</a>) to retrieve the <a>Property</a> values given by |propertyNames| with |form| and optional URI templates given in |options|' |uriVariables|.
          </li>
          <li>
            If this cannot be done with a single request with the <a>Protocol Bindings</a>, [=reject=] |promise| with a {{NotSupportedError}} and stop.
          </li>
          <li>
            Process the response and for each |key| in |result|, run the following
            sub-steps:
            <ol>
              <li>
                Let |value| be |result|[|key|].
              </li>
              <li>
                Let |schema| be |this|.{{ConsumedThing/[[td]]}}.|properties|[|key|].
              </li>
              <li>
                Let |property| be the result of running
                <a>parse interaction response</a> on |value|, |form| and
                |schema|.
              </li>
            </ol>
          </li>
          <li>
            If the above step throws at any point, [=reject=] |promise| with that
            exception and stop.
          </li>
          <li>
            [=Resolve=] |promise| with |result|.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>The <dfn>readAllProperties()</dfn> method</h3>
      <div>
        Reads all properties of the <a>Thing</a> with one request. Takes |options:InteractionOptions| as optional argument.
        It returns a {{Promise}} that resolves with a {{PropertyReadMap}} object that
        maps keys from <a>Property</a> names to values returned by this algorithm.
        The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            Let |forms| be |subscription|.{{Subscription/[[interaction]]}}.|forms|.
          </li>
          <li>
            If |forms| is `undefined`, [=reject=] |promise| with a
            {{SyntaxError}} and stop.
          </li>
          <li>
            If |option|.|formIndex| is not `undefined` and is less than |forms|.|length|, set |subscription|.{{Subscription/[[form]]}} to |forms|.[|formIndex|].
          </li>
          <li>
             Otherwise, set |subscription|.{{Subscription/[[form]]}} to a
            <a>Form</a> in |forms| whose |op| is `"readallproperties"`, as selected by the implementation.
          </li>
          <li>
            If |subscription|.{{Subscription/[[form]]}} is failure, [=reject=] |promise| with a {{SyntaxError}} and stop.
          </li>
          <li>
            Make a request to the underlying platform using the <a>Protocol Bindings</a> to retrieve  all the <a>Property</a> definitions from the <a>TD</a> given |form| and optional URI templates in |options|.|uriVariables|.
          </li>
          <li>
            If this cannot be done with a single request with the <a>Protocol Bindings</a> of the <a>Thing</a>, then [=reject=] |promise| with a {{NotSupportedError}} and stop.
          </li>
          <li>
            If the request fails, [=reject=] |promise| with the error received from the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Process the reply and let |result:object| be an object with the keys and values obtained in the reply.
          </li>
          <li>
            Process the response and for each |key| in |result|, run the following
            sub-steps:
            <ol>
              <li>
                Let |value| be |result|[|key|].
              </li>
              <li>
                Let |schema| be |this|.{{ConsumedThing/[[td]]}}.|properties|[|key|].
              </li>
              <li>
                Let |property| be the result of running
                <a>parse interaction response</a> on |value|, |form| and
                |schema|.
              </li>
            </ol>
          </li>
          <li>
            [=Resolve=] |promise| with |result|.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>The <dfn>writeProperty()</dfn> method</h3>
      <div>
        Writes a single <a>Property</a>. Takes as arguments |propertyName:string|,
        |value:InteractionInput| and optionally |options:InteractionOptions|.
        It returns a {{Promise}} that resolves on success and rejects on failure.
        The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ConsumedThing/[[td]]}}.|properties|[|propertyName|].
          </li>
          <li>
            If |interaction| is `undefined`, [=reject=] |promise| with a {{NotFoundError}}
            and stop.
          </li>
          <li>
            If |option|.|formIndex| is not `undefined`, let |form| be the
            <a>Form</a> associated with |formIndex| in the |interaction|.|forms|
            array, otherwise let |form| be a <a>Form</a> in
            |interaction|.|forms| whose |op| is `writeproperty`, as selected by
            the implementation.
          </li>
          <li>
            If |form| is failure, [=reject=] |promise| with a {{SyntaxError}} and stop.
          </li>
          <li>
            Let |data| be the result of running the <a>create interaction request</a> steps given |value|, |form| and |interaction|. If that throws, [=reject=] <a>promise</a> with that exception and stop.
          </li>
          <li>
            Make a request to the underlying platform (via the <a>Protocol Bindings</a>)
            to write the <a>Property</a> given by |propertyName| using
            |data:InteractionOutput| and the optional URI templates given in
            |options|' |uriVariables|.
          </li>
          <li>
            If the request fails, [=reject=] |promise| with the error received from the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Otherwise [=resolve=] |promise|.
          </li>
        </ol>
      </div>
      <p class="ednote">
        As discussed in <a href="https://github.com/w3c/wot-scripting-api/issues/193">
        Issue #193</a>, the design decision is that write interactions only
        return success or error, not the written value (optionally).
        <a>TD</a>s should capture the schema of the <a>Property</a>
        values, including precision and alternative formats. When a return
        value is expected from the interaction, an <a>Action</a> should be used
        instead of a <a>Property</a>.
      </p>
    </section>

    <section>
      <h3>The <dfn>writeMultipleProperties()</dfn> method</h3>
      <div>
        Writes a multiple <a>Property</a> values with one request.
        Takes as arguments |properties:object| - as an object with keys being
        <a>Property</a> names and values as <a>Property</a> values - and optionally
        |options:InteractionOptions|.
        It returns a {{Promise}} that resolves on success and rejects on failure. The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps
            [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting
            context for security reasons, [=reject=] |promise| with a
            {{SecurityError}} and stop.
          </li>
          <li>
            If |option|.|formIndex| is defined, let |form| be the
            <a>Form</a> associated with |formIndex| in the {{ConsumedThing/[[td]]}}.|forms| array,
            otherwise let |form| be a <a>Form</a> in {{ConsumedThing/[[td]]}}.|forms|
            array whose |op| is `writemultipleproperties`, as selected by
            the implementation.
          </li>
          <li>
            If |form| is failure, [=reject=] |promise| with a {{SyntaxError}} and
            stop.
          </li>
          <li>
            Let |propertyNames| be an array of |string| with as elements the keys of the |properties| object.
          </li>
          <li>
            For each |name:string| in |propertyNames|, let |property| be |this|.{{ConsumedThing/[[td]]}}.|properties|[|name|].
          </li>
          <li>
            If |property| is `null` or `undefined` or is not `writeable` [=reject=] |promise| with {{NotSupportedError}} and stop.
          </li>
          <li>
            Let |result:object| be an object and for each string |name:string| in |propertyNames| add a property with key |name| and let its value be
            `null`.
          </li>
          <li>
            Let |schemas:object| be an object and for each |name:string|
            in |propertyNames| add a property with key |name| and let its value
            be |this|.{{ConsumedThing/[[td]]}}.|properties|[|name|].
          </li>
          <li>
            For each key |key:string| in |properties|,
            run the <a>create interaction request</a> steps given
            |properties|[|key|], |form| and the value for |schema|[|key|].
            If that throws for any |name|, [=reject=] <a>promise</a> with that
            exception and stop.
          </li>
          <li>
            Make a single request to the underlying platform (via the
            <a>Protocol Bindings</a>) to write each <a>Property</a> provided in
            |properties| with optional URI templates given in |options|'
            |uriVariables|.
          </li>
          <li>
            If this cannot be done with a single request with the
            <a>Protocol Bindings</a> of the <a>Thing</a>, then [=reject=] |promise|
            with a {{NotSupportedError}} and stop.
          </li>
          <li>
            If the request fails, return the error received from the
            <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Otherwise [=resolve=] |promise|.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>The <dfn>observeProperty()</dfn> method</h3>
      <div>
        Makes a request for <a>Property</a> value change notifications.
        Takes as arguments |propertyName:string|, |listener:InteractionListener| and
        optionally |onerror:ErrorListener| and |options:InteractionOptions|.
        It returns a {{Promise}} that resolves on success and rejects on failure.
        <p class="ednote">
          This algorithm allows for only one active {{Subscription}} per <a>Property</a>. If a new
          {{Subscription}} is made while an existing {{Subscription}} is active the runtime
          will throw an {{NotAllowedError}}.
        </p>
        The method MUST run the following steps:
        <ol>
          <li>
            Let |thing| be the reference of this {{ConsumedThing}} object.
          </li>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            If |listener| is not a {{Function}}, [=reject=] |promise|
            with a {{TypeError}} and stop.
          </li>
          <li>
            If |onerror| is not `null` and is not a {{Function}}, [=reject=] |promise|
            with a {{TypeError}} and stop.
          </li>
          <li>
            If |thing|.{{ConsumedThing/[[activeObservations]]}}[|propertyName|] [=map/exists], [=reject=] |promise| with a {{NotAllowedError}} and stop.
          </li>
          <li>
            Let |subscription| be a new {{Subscription}} object with its <a>internal slots</a>
            set as follows:
            <ul>
              <li>
                Let |subscription|.{{Subscription/[[type]]}} be `"property"`.
              </li>
              <li>
                Let |subscription|.{{Subscription/[[name]]}} be |propertyName|.
              </li>
              <li>
                Let |subscription|.{{Subscription/[[interaction]]}} be  {{ConsumedThing/[[td]]}}.|properties|[|propertyName|].
              </li>
              <li>
                Let |subscription|.{{Subscription/[[thing]]}} be |thing|.
              </li>
              <li>
                Let |forms| be |subscription|.{{Subscription/[[interaction]]}}.|forms|.
              </li>
              <li>
                If |forms| is `undefined`, [=reject=] |promise| with a
                {{SyntaxError}} and stop.
              </li>
              <li>
                If |option|.|formIndex| is not `undefined` and is less than |forms|.|length|, set |subscription|.{{Subscription/[[form]]}} to |forms|.[|formIndex|].
              </li>
              <li>
                 Otherwise, set |subscription|.{{Subscription/[[form]]}} to a
                <a>Form</a> in |forms| whose |op| is `"observeproperty"`, as selected by the implementation.
              </li>
              <li>
                If |subscription|.{{Subscription/[[form]]}} is failure, [=reject=] |promise| with a
                {{SyntaxError}} and stop.
              </li>
              <li>
                If |subscription|.{{Subscription/[[interaction]]}} is `undefined`, [=reject=] |promise| with a {{NotFoundError}} and stop.
              </li>
            </ul>
          </li>
          <li>
            Make a request to the underlying platform to observe the
            <a>Property</a> identified by |propertyName| with |form| and
            optional URI templates given in |options|' |uriVariables|.
          </li>
          <li>
            If the request fails, [=reject=] |promise| with the error received from
            the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            [=map/Set=] |thing|.{{ConsumedThing/[[activeObservations]]}}[|propertyName] to |subscription| and [=resolve=] |promise|.
          </li>
          <li>
            Whenever the underlying platform detects a notification for this
            |subscription| [=map/keyed=] on |propertyName| with a new <a>Property</a> value |value|,
            run the following sub-steps:
            <ul>
              <li>
                Let |reply| be the result of running <a>parse interaction response</a>
                with |value|, |subscription|.{{Subscription/[[form]]}} and |subscription|.{{Subscription/[[interaction]]}}.
                If that throws, [=reject=] |promise| with that exception and stop.
              </li>
              <li>
                Invoke |listener| given |reply|.
              </li>
            </ul>
          </li>
          <li>
            Whenever the underlying platform detects an error for
            this subscription, run the following sub-steps:
            <ul>
              <li>
                If the error is irrecoverable and stops the subscription, set
                |subscription|.|active| to `false` and suppress further notifications.
              </li>
              <li>
                Let |error| be a new {{NetworkError}} and set its |message|
                to reflect the underlying error condition.
              </li>
              <li>
                If |onerror| is a {{Function}},  invoke it given |error|.
              </li>
            </ul>
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>The <dfn>invokeAction()</dfn> method</h3>
      <div>
        Makes a request for invoking an <a>Action</a> and return the result.
        Takes as arguments |actionName:string|, optionally
        |params:InteractionInput| and optionally |options:InteractionOptions|.
        It returns a {{Promise}} that resolves with the result of the <a>Action</a>
        represented as an {{InteractionOutput}} object, or rejects with an error.
        The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ConsumedThing/[[td]]}}.|actions|[|actionName|].
          </li>
          <li>
            If |interaction| is not an {{object}}, [=reject=] |promise| with a {{NotFoundError}}
            and stop.
          </li>
          <li>
            Let |forms| be |subscription|.{{Subscription/[[interaction]]}}.|forms|.
          </li>
          <li>
            If |forms| is `undefined`, [=reject=] |promise| with a
            {{SyntaxError}} and stop.
          </li>
          <li>
            If |option|.|formIndex| is not `undefined` and is less than |forms|.|length|, set |subscription|.{{Subscription/[[form]]}} to |forms|.[|formIndex|].
          </li>
          <li>
             Otherwise, set |subscription|.{{Subscription/[[form]]}} to a
            <a>Form</a> in |forms| whose |op| is `"invokeaction"`, as selected by the implementation.
          </li>
          <li>
            If |subscription|.{{Subscription/[[form]]}} is failure, [=reject=] |promise| with a
            {{SyntaxError}} and stop.
          </li>
          <li>
            Let |args| be the result of running the <a>create interaction request</a> steps on |params|, |form| and |interaction|. If that throws, [=reject=] <a>promise</a> with that exception and stop.
          </li>
          <li>
            Make a request to the underlying platform (via the <a>Protocol Bindings</a>) to invoke the <a>Action</a> identified by |actionName| given |args| and |options|.|uriVariables|.
          </li>
          <li>
            If the request fails locally or returns an error over the network, [=reject=] |promise| with the error received from the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |value| be the reply returned in the reply.
          </li>
          <li>
            Let |result| be the result of running <a>parse interaction response</a>
            with |value|, |form| and |interaction|. If that throws, [=reject=] |promise| with that exception and stop.
          </li>
          <li>
            [=Resolve=] |promise| with |result|.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>The <dfn>subscribeEvent()</dfn> method</h3>
      <div>
        Makes a request for subscribing to <a>Event</a> notifications.
        Takes as arguments |eventName:string|, |listener:WoTListener| and
        optionally  |onerror:ErrorListener| and |options:InteractionOptions|.
        It returns a {{Promise}} to signal success or failure.
        <p class="ednote">
          This algorithm allows for only one active {{Subscription}} per <a>Event</a>. If a new
          {{Subscription}} is made while an existing {{Subscription}} is active the runtime
          will throw an {{NotAllowedError}}.
        </p>
        The method MUST run the following steps:
        <ol>
          <li>
            Let |thing| be the reference of this {{ConsumedThing}} object.
          </li>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            If |listener| is not a {{Function}}, [=reject=] |promise|
            with a {{TypeError}} and stop.
          </li>
          <li>
            If |onerror| is not `null` and is not a {{Function}}, [=reject=] |promise|
            with a {{TypeError}} and stop.
          </li>
          <li>
            If |thing|.{{ConsumedThing/[[activeSubscriptions]]}}[|eventName|] does not [=map/exist=], [=reject=] |promise| with a {{NotAllowedError}} and stop.
          </li>
          <li>
            Let |subscription| be a new {{Subscription}} object with its <a>internal slots</a>
            set as follows:
            <ul>
              <li>
                Let |subscription|.{{Subscription/[[type]]}} be `"event"`.
              </li>
              <li>
                Let |subscription|.{{Subscription/[[name]]}} be |eventName|.
              </li>
              <li>
                Let |subscription|.{{Subscription/[[interaction]]}} be |thing|. {{ConsumedThing/[[td]]}}.|events|[|eventName|].
              </li>
              <li>
                If |subscription|.{{Subscription/[[interaction]]}} is `undefined`, [=reject=] |promise| with a {{NotFoundError}} and stop.
              </li>
              <li>
                Let |subscription|.{{Subscription/[[thing]]}} be |thing|.
              </li>
              <li>
                If |options|.|formIndex| [=map/exists=], then let |subscription|.{{Subscription/[[form]]}} be  |thing|.{{Subscription/[[interaction]]}}.|forms|[|formIndex|].
              </li>
              <li>
                Otherwise, let |subscription|.{{Subscription/[[form]]}} be an [=implementation-defined=]
                <a>Form</a> from the |subscription|.{{Subscription/[[interaction]]}}.|forms| array whose |op| is `"subscribeevent"`.
              </li>
              <li>
                If |subscription|.{{Subscription/[[form]]}} does not [=map/exist=],
                [=reject=] |promise| with a {{SyntaxError}} and stop.
              </li>
            </ul>
          </li>
          <li>
            Make a request to the underlying platform via the <a>Protocol Bindings</a>
            to subscribe to the <a>Event</a> identified by |eventName:string| with
            {{Subscription/[[form]]}}, optional URI templates given in |options|.|uriVariables|
            and optional subscription data given in |options|.|data|.
          </li>
          <li>
            If the request fails, [=reject=] |promise| with the error received from
            the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            [=map/Set=] |eventName| to |thing|.{{ConsumedThing/[[activeSubscriptions]]}}[|eventName|] to |subscription|.
          </li>
          <li>
             [=Resolve=] |promise|.
          </li>
          <li>
            Whenever the underlying platform detects a notification for the
            <a>Event</a> |subscription| [=map/keyed=] on |eventName|, run the following sub-steps:
            <ol>
              <li>
                Invoke |listener| given the result of running
                <a>parse interaction response</a> on the data provided with the
                <a>Event</a>, |subscription|.{{Subscription/[[form]]}} and |subscription|.{{Subscription/[[interaction]]}}.
              </li>
            </ol>
          </li>
          <li>
            Whenever the underlying platform detects an error for
            <a>Event</a> |subscription| [=map/keyed=] on |eventName|, run the following sub-steps:
            <ul>
              <li>
                If the error is irrecoverable and stops the subscription, set
                |subscription|.|active| to `false` and suppress further notifications.
              </li>
              <li>
                Let |error| be a new {{NetworkError}} and set its |message|
                to reflect the underlying error condition.
              </li>
              <li>
                If |onerror| is a {{Function}}, invoke it given |error|.
              </li>
            </ul>
          </li>
        </ol>
      </div>
    </section>

    <section data-dfn-for="InteractionOptions">
      <h3>
        The <dfn>InteractionOptions</dfn> dictionary
      </h3>
      <p>
        Holds the interaction options that need to be exposed for application scripts according to the <a>Thing Description</a>.
      </p>
      <p>
        The <dfn>formIndex</dfn> property, if defined, represents an application
        hint for which <code>Form</code> definition, identified by this index,
        of the <a>TD</a> to use for the given WoT interaction.
        Implementations SHOULD use the <code>Form</code> with this index for
        making the interaction, but MAY override this value if the index is not
        found or not valid.
        If not defined, implementations SHOULD attempt to use the
        <code>Form</code> definitions in order of appearance as listed in the
        <a>TD</a> for the given Wot Interaction.
      </p>
      <p>
        The <dfn>uriVariables</dfn> property if defined, represents the URI
        template variables to be used with the WoT Interaction that are represented
        as <a data-cite="infra#parse-json-bytes-to-a-javascript-value">
        parsed JSON objects</a> defined in [[!WOT-TD]].
      </p>
      <p class="ednote">
        The support for URI variables comes from the need, exposed by the [[[WOT-TD]]] specification, to be able to describe
        existing RESTful endpoints that use them. However, it should be possible to write a Thing Description that would use
        <a>Action</a>s for representing this kind of interactions and model the URI variables as action parameters. In that case,
        implementations can serialize the parameters as URI variables, and therefore, the |options| parameter could be
        dismissed.
      </p>
      <p>
        The <dfn>data</dfn> property if defined, represents additional opaque
        data that needs to be passed to the interaction.
      </p>
    </section>

    <section>
      <h3>The <dfn>PropertyReadMap</dfn> type</h3>
      <p>
        Represents a map of <a>Property</a> names to an <a>InteractionOutput</a>
        object that represents the value the <a>Property</a> can take. It is
        used as a property bag for interactions that involve multiple
        <a>Properties</a> at once.
      </p>
    </section>

    <section>
      <h3>The <dfn>PropertyWriteMap</dfn> type</h3>
      <p>
        Represents a map of <a>Property</a> names to an <a>InteractionInput</a>
        that represents the value the <a>Property</a> can take. It is
        used as a property bag for interactions that involve multiple
        <a>Properties</a> at once.
      </p>
    </section>

    <section>
      <h3>The <dfn>InteractionListener</dfn> callback</h3>
      <p>
        User provided callback that is given an argument of type
        {{InteractionOutput}} and is used for observing <a>Property</a> changes
        and handling <a>Event</a> notifications.
        Since subscribing to <a>Events</a> are WoT interactions and might take
        options or even data, they are not modelled with software events.
      </p>
    </section>

    <section>
      <h3>The <dfn>ErrorListener</dfn> callback</h3>
      <p>
        User provided callback that is given an argument of type
        {{Error}} and is used for conveying critical and non-critical errors
        from the <a>Protocol Bindings</a> to applications.
      </p>
    </section>

    <section data-dfn-for="Subscription">
      <h3>The <dfn>Subscription</dfn> interface</h3>
      <p>
        Represents a subscription to <a>Property</a> change and <a>Event</a>
        interactions.
      </p>
      <p>
        The <dfn>active</dfn> boolean property denotes if the subscription is
        active, i.e. it is not stopped because of an error or because of invocation
        of the <code>stop()</code> method.
      </p>
      <section><h4>Internal slots for {{Subscription}}</h4>
        A {{Subscription}} object has the following <a>internal slots</a>:
        <table class="simple">
          <thead>
           <tr>
            <th>Internal Slot</th>
            <th>Initial value</th>
            <th>Description (<em>non-normative</em>)</th>
           </tr>
          </thead>
          <tbody data-link-for="Subscription">
           <tr>
            <td><dfn>[[\type]]</dfn></td>
            <td>`null`</td>
            <td>
              Indicates what <a>WoT Interaction</a> the {{Subscription}} refers to.
              The value can be either `"property"` or `"event"` or `null`.
            </td>
           </tr>
           <tr>
             <td><dfn>[[\name]]</dfn></td>
             <td>`null`</td>
             <td>The <a>Property</a> or <a>Event</a> name.</td>
           </tr>
           <tr>
             <td><dfn>[[\interaction]]</dfn></td>
             <td>`null`</td>
             <td>
              The <a>Thing Description</a> fragment that describes the
              <a>WoT interaction</a>.
              </td>
           </tr>
           <tr>
             <td><dfn>[[\form]]</dfn></td>
             <td>`null`</td>
             <td>The <a>Form</a> associated with the subscription.</td>
           </tr>
           <tr>
             <td><dfn>[[\thing]]</dfn></td>
             <td>`null`</td>
             <td>The <a>ConsumedThing</a> associated with the subscription.</td>
           </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h4>The <dfn>stop()</dfn> method</h4>
        <p>
          Stops delivering notifications for the subscription. It takes an
          optional parameter |options:InteractionOptions| and returns a {{Promise}}.
          When invoked, the method MUST execute the following steps:
          <ol>
            <li>
              Return a {{Promise}} |promise:Promise| and execute the next steps
              [=in parallel=].
            </li>
            <li>
              If invoking this method is not allowed for the current scripting
              context for security reasons, [=reject=] |promise| with a
              {{SecurityError}} and stop.
            </li>
            <li>
              If |options|' |formIndex| is defined, let |unsubscribeForm| be the
              <a>Form</a> associated with |formIndex| in {{Subscription/[[interaction]]}}'s
              |forms| array.
            </li>
            <li>
              Otherwise let |unsubscribeForm| be the result of running the
              <a>find a matching unsubscribe form</a> algorithm given {{Subscription/[[form]]}}.
            </li>
            <li>
              If |unsubscribeForm| is failure, [=reject=] |promise| with a {{SyntaxError}} and
              stop.
            </li>
            <li>
              If {{Subscription/[[type]]}} is `"property"`, make a request to the underlying
              platform via the <a>Protocol Bindings</a> to stop observing the
              <a>Property</a> identified by {{Subscription/[[name]]}} with |unsubscribeForm| and optional
              URI templates given in |options|' |uriVariables|.
            </li>
            <li>
              Otherwise, if {{Subscription/[[type]]}} is `"event"`, make a request to the underlying
              platform via the <a>Protocol Bindings</a> to unsubscribe from the
              <a>Event</a> identified by {{Subscription/[[name]]}} with |unsubscribeForm|, with optional URI
              templates given in |options|' |uriVariables| and optional
              unsubscribe data given in |options|.|data|.
            </li>
            <li>
              If the request fails, [=reject=] |promise| with the error received from
              the <a>Protocol Bindings</a> and stop.
            </li>
            <li>
              Otherwise:
              <ul>
                <li>
                  set <a href="#dom-subscription-active">active</a> to `false`.
                </li>
                <li>
                  if {{Subscription/[[type]]}} is `"event"`, remove {{Subscription/[[name]]}} from {{Subscription/[[thing]]}}.{{ConsumedThing/[[activeSubscriptions]]}} .
                </li>
                <li>
                  if {{Subscription/[[type]]}} is `"property"`, remove {{Subscription/[[name]]}} from {{Subscription/[[thing]]}}.{{ConsumedThing/[[activeObservations]]}} .
                </li>
                <li>
                  [=Resolve=] |promise|.
                </li>
              </ul>
            </li>
            <li>
              If the underlying platform receives further notifications for this
              subscription, implementations SHOULD silently suppress them.
            </li>
          </ol>
        </p>
      </section>
      <section><h4>Finding an unsubscribe <a>Form</a></h4>
        <p class="note">
          This algorithm is under development and is <em>non-normative</em>.
          Implementations MAY choose another algorithm to find a matching
          `unsubscribe` <a>Form</a> to a given `subscribe` <a>Form</a>.
        </p>
        To <dfn>find a matching unsubscribe form</dfn> given |subscribeForm|
        in the context of a {{Subscription}} object, run the following steps:
        <ol>
          <li>
            Let |results| be an empty array.
          </li>
          <li>
            For each |form| in {{Subscription/[[interaction]]}}.|forms|,
            <ol>
              <li>
                Add an <a>internal slot</a> [[\matchLevel]] on |form| and set
                its value to `0`.
              </li>
              <li>
                If |form|.|op| is `"unobserveproperty"` if {{Subscription/[[type]]}} is
                `"property"` or if |form|.|op| is `"unsubscribeevent"`
                if {{Subscription/[[type]]}} is`"event"`,
                <ol>
                  <li>
                    Set the <a>internal slot</a> [[\matchLevel]] on |form| to 1
                    and add |form| to |results|.
                  </li>
                  <li>
                    If |form|.|href| and [[\subscribeForm]].|href| are
                    <a data-cite="html#same-origin-domain">
                    same origin-domain</a>, increment |form|.[[\matchLevel]].
                  </li>
                  <li>
                    If |form|.|contentType| is equal to [[\subscribeForm]]'s
                    |contentType| and |form|.[[\matchLevel]] is greater than 2,
                    increment |form|.[[\matchLevel]].
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            If |results| is empty, return `null` and terminate these steps.
          </li>
          <li>
            Return the first |form| in |results| that has the highest
            [[\matchLevel]] value.
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>ConsumedThing Examples</h2>
      <p>
        The next example illustrates how to fetch a <a>TD</a> by URL, create a {{ConsumedThing}}, read metadata (title), read property value, subscribe to property change, subscribe to a WoT event, unsubscribe.
      </p>
      <pre class="example" title="Thing Client API example with data value">
        try {
          let res = await fetch("https://tds.mythings.org/sensor11");
          let td = res.json();
          let thing = new ConsumedThing(td);
          console.log("Thing " + thing.getThingDescription().title + " consumed.");
        } catch (e) {
          console.log("TD fetch error: " + e.message);
        };

        try {
          // subscribe to property change for "temperature"
          await thing.observeProperty("temperature", async (data) => {
            try {
              console.log("Temperature changed to: " + await data.value());
            } catch (error) {
              console.error("Cannot read the observed property temperature");
              console.error(error);
            }
          });
          // subscribe to the "ready" event defined in the TD
          await thing.subscribeEvent("ready", async (eventData) => {
            try {
              console.log("Ready; index: " + await eventData.value());
              // run the "startMeasurement" action defined by TD
              await thing.invokeAction("startMeasurement", { units: "Celsius" });
              console.log("Measurement started.");
            } catch (error) {
              console.error("Cannot read the ready event or startMeasurement failed");
              console.error(error)
            }
          });
        } catch (e) {
          console.log("Error starting measurement.");
        }

        setTimeout(async () => {
          try {
            const temperatureData = await thing.readProperty("temperature")
            const temperature = await temperatureData.value();
            console.log("Temperature: " + temperature);

            await thing.unsubscribe("ready");
            console.log("Unsubscribed from the 'ready' event.");
          } catch (error) {
            console.log("Error in the cleanup function");
          }
        }, 10000);
      </pre>
      <p>
        The following shows an advance usage of {{InteractionOutput}} to read a property without a {{DataSchema}}.
      </p>
      <pre class="example" title="Thing Client API example with arrayBuffer">
        /*
        * takePicture affordance form:
        * "form": {
        *   "op": "invokeaction",
        *   "href" : "http://camera.example.com:5683/takePicture",
        *   "response": {
        *     "contentType": "image/jpeg",
        *     "contentCoding": "gzip"
        *   }
        *}
        * See https://www.w3.org/TR/wot-thing-description/#example-23
        */
        let response;
        let image;
        try {
          response = await thing.invokeAction("takePicture");
          image = await response.value() // throws NotReadableError --> schema not defined
        } catch(ex) {
          image = await response.arrayBuffer();
          // image: ArrayBuffer [0x1 0x2 0x3 0x5 0x15 0x23 ...]
        }
      </pre>
      <p>
        Finally, the next two examples shows the usage of a {{ReadableStream}} from an {{InteractionOutput}}.
      </p>
      <pre class="example" title="Thing Client API example with readable stream (e.g., video stream)">
        /*{
        "video": {
          "description" : "the video stream of this camera",
          "forms": [
            {
              "op": "readproperty",
              "href": "http://camera.example.com/live",
              "subprotocol": "hls"
              "contentType": "video/mp4"
            }
          ]
        }}*/

        const video = await thing.readProperty("video")
        const reader = video.data.getReader()
        reader.read().then(function processVideo({ done, value }) {
          if (done) {
            console.log("live video stoped");
            return;
          }
          const decoded = decode(value)
          UI.show(decoded)
          // Read some more, and call this function again
          return reader.read().then(processText);
        });
      </pre>
      <p>Here consider that the JSON object is too big to be read wholly in the memory. Therefore,
        we use streaming processing to get the total number of the events recorded by the remote Web Thing.
      </p>
      <pre class="example" title="Thing Client API example with readable stream (e.g., counting json objects)">
        /*
        * "eventHistory":
        * {
        *   "description" : "A long list of the events recorded by this thing",
        *   "type": "array",
        *   "forms": [
        *     {
        *       "op": "readproperty",
        *       "href": "http://recorder.example.com/eventHistory",
        *     }
        *   ]
        * }
        */

        // Example of streaming processing: counting json objects
        let objectCounter = 0
        const parser = new Parser() //User library for json streaming parsing (i.e. https://github.com/uhop/stream-json/wiki/Parser)

        parser.on('data', data => data.name === 'startObject' && ++objectCounter);
        parser.on('end', () => console.log(`Found ${objectCounter} objects.`));

        const response = await thing.readProperty("eventHistory")
        await response.data.pipeTo(parser);

        // Found N objects
      </pre>
    </section> <!-- Examples -->
  </section> <!-- ConsumedThing -->

  <section data-cite="webidl" data-dfn-for="ExposedThing">
    <h2>The <dfn>ExposedThing</dfn> interface</h2>
    <p>
      The {{ExposedThing}} interface is the server API to operate the <a>Thing</a> that allows defining request handlers, <a>Property</a>, <a>Action</a>, and <a>Event</a> interactions.
    </p>
    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ExposedThing {
        ExposedThing setPropertyReadHandler(DOMString name,
                PropertyReadHandler handler);
        ExposedThing setPropertyWriteHandler(DOMString name,
                PropertyWriteHandler handler);
        ExposedThing setPropertyObserveHandler(DOMString name,
                PropertyReadHandler handler);
        ExposedThing setPropertyUnobserveHandler(DOMString name,
                PropertyReadHandler handler);
        Promise&lt;undefined&gt; emitPropertyChange(DOMString name,
                optional InteractionInput data);

        ExposedThing setActionHandler(DOMString name, ActionHandler action);

        ExposedThing setEventSubscribeHandler(DOMString name,
                EventSubscriptionHandler handler);
        ExposedThing setEventUnsubscribeHandler(DOMString name,
                EventSubscriptionHandler handler);
        Promise&lt;undefined&gt; emitEvent(DOMString name,
                optional InteractionInput data);

        Promise&lt;undefined&gt; expose();
        Promise&lt;undefined&gt; destroy();

        ThingDescription getThingDescription();
      };

      callback PropertyReadHandler = Promise&lt;InteractionInput&gt;(
              optional InteractionOptions options = {});

      callback PropertyWriteHandler = Promise&lt;undefined&gt;(
              InteractionOutput value,
              optional InteractionOptions options = {});

      callback ActionHandler = Promise&lt;InteractionInput&gt;(
              InteractionOutput params,
              optional InteractionOptions options = {});

      callback EventSubscriptionHandler = Promise&lt;undefined&gt;(
              optional InteractionOptions options = {});

    </pre>

    <section data-dfn-for="ExposedThing">
      <h4>Internal slots for ExposedThing</h4>
      <p>
        An {{ExposedThing}} object has the following <a>internal slots</a>:
      </p>
      <table class="simple">
        <thead>
         <tr>
          <th>Internal Slot</th>
          <th>Initial value</th>
          <th>Description (<em>non-normative</em>)</th>
         </tr>
        </thead>
        <tbody data-link-for="ExposedThing">
          <tr>
            <td><dfn>[[\td]]</dfn></td>
            <td>`null`</td>
            <td>The <a>Thing Description</a> of the {{ExposedThing}}.</td>
          </tr>
          <tr>
            <td><dfn>[[\readHandlers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with property names as keys and {{PropertyReadHandler}}s as values</td>
          </tr>
          <tr>
            <td><dfn>[[\writeHandlers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with property names as keys and {{PropertyWriteHandler}}s as values</td>
          </tr>
          <tr>
            <td><dfn>[[\observeHandlers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with property names as keys and {{PropertyReadHandler}}s as values</td>
          </tr>
          <tr>
            <td><dfn>[[\unobserveHandlers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with property names as keys and {{Function}}s as values</td>
          </tr>
          <tr>
            <td><dfn>[[\actionHandlers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with action names as keys and {{ActionHandler}}s as values</td>
          </tr>
          <tr>
            <td><dfn>[[\subscribeHandlers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with event names as keys and {{EventSubscriptionHandler}}s as values</td>
          </tr>
          <tr>
            <td><dfn>[[\unsubscribeHandlers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with event names as keys and {{EventSubscriptionHandler}}s as values</td>
          </tr>
          <tr>
            <td><dfn>[[\propertyObservers]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with property names as keys and an {{Array}} of listeners as values</td>
          </tr>
          <tr>
            <td><dfn>[[\eventListeners]]</dfn></td>
            <td>`{}`</td>
            <td>A {{Map}} with event names as keys and {{Array}} of listeners as values</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h3>Creating {{ExposedThing}}</h3>
      <p>
        The {{ExposedThing}} interface
        is created from a full or partial {{ThingDescription}} object.
      </p>
      <p class="note">
         Note that an existing {{ThingDescription}} object can be optionally modified (for instance by adding or removing elements on its |properties|, |actions| and |events| internal properties) and the resulting object can used for creating an
         {{ExposedThing}} object. This is the current way of adding and
         removing <a>Property</a>, <a>Action</a> and <a>Event</a> definitions, as illustrated in the <a href="#exposedthing-examples">examples</a>.
      </p>
      <p class="note">
        Before invoking <a href="#dom-exposedthing-expose">expose()</a>, the {{ExposedThing}} object does not serve any requests. This allows first creating {{ExposedThing}} and then initialize its <a>Properties</a> and service handlers before starting serving requests.
      </p>
      <div>
        To create an {{ExposedThing}} with the {{ExposedThingInit}}
        |init:ExposedThingInit|, run the following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>Run the <a>expand an ExposedThingInit</a> steps on |init|. if that fails re-[= exception/throw =] the error and stop. Otherwise store the obtained |td:ThingDescription| </li>
          <li>
            Run the <a>expand a TD</a> steps on |td|. If that fails, re-[= exception/throw =] the error and stop.
          </li>
          <li>
            Let |thing:ExposedThing| be a new {{ExposedThing}} object.
          </li>
          <li>
            Set the {{ExposedThing/[[td]]}} of |thing| to |td|.
          </li>
          <li>
            Return |thing|.
          </li>
        </ol>
      </div>
    </section>

    <section data-dfn-for="ExposedThing">
      <h3>The <dfn>getThingDescription()</dfn> method</h3>
      <p>
        Returns the {{ExposedThing/[[td]]}} of the {{ExposedThing}} object
        that represents the <a>Thing Description</a> of the <a>Thing</a>.
        Applications may consult the <a>Thing</a> metadata stored in {{ExposedThing/[[td]]}} in
        order to introspect its capabilities before interacting with it.
      </p>
    </section>

    <section data-dfn-for="PropertyReadHandler">
      <h3>The <dfn>PropertyReadHandler</dfn> callback</h3>
      <p>
        A function that is called when an external request for reading a
        <a>Property</a> is received and defines what to do with such requests.
        It returns a {{Promise}} and resolves with an {{ReadableStream}} object or an
        <a data-cite="ECMASCRIPT#sec-ecmascript-data-types-and-values">
        ECMAScript value</a> conforming to <a>DataSchema</a>, or rejects with an
        error.
      </p>
    </section>

    <section> <h3>The <dfn>setPropertyReadHandler()</dfn> method</h3>
      <p>
        Takes as arguments |name:string| and |handler:PropertyReadHandler|.
        Sets the service handler that defines what to do when a request is
        received for reading the specified <a>Property</a> matched by |name|.
        Throws on error.
        Returns a reference to |this| object for supporting chaining.
      </p>
      <p class="ednote">
        Note that there is no need to register handlers for handling requests
        for reading multiple or all <a>Properties</a>. The request and reply
        are transmitted in a single network request, but the <a>ExposedThing</a>
        may implement them using multiple calls to the single read handler.
      </p>
      <p>
         The |handler| callback function should implement reading a <a>Property</a> and SHOULD be called by implementations when a request for reading a <a>Property</a> is received from the underlying platform.
      </p>
      <p>
        There MUST be at most one handler for any given <a>Property</a>, so newly added handlers MUST replace the previous handlers. If no handler is initialized for any given <a>Property</a>, implementations SHOULD implement a default property read handler based on the <a>Thing Description</a> provided in the {{ExposedThing/[[td]]}} <a>internal slot</a>.
      </p>
      <div>
        When the method is invoked given |name:string| and
        |handler:PropertyReadHandler|, implementations MUST run the
        following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>
            If {{ExposedThing/[[td]]}}.|properties|[|name|] does not [=map/exist=],
            [= exception/throw =] {{NotFoundError}} and stop.
          </li>
          <li>
            Set |this|.{{ExposedThing/[[readHandlers]]}}[|name|] to |handler|.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling requests for reading a Property</h3>
      <div>
        When a network request for reading <a>Property</a> |name:string|
        is received by the implementation with |options:InteractionOptions|,
        run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |value| be the result of running the <dfn>read server property</dfn>
            steps with |name:string| and |options:InteractionOptions|:
            <ol>
              <li>
                Let |interaction| be {{ExposedThing/[[td]]}}.|properties|.|name|.
              </li>
              <li>
                If a <a>Property</a> with |name| does not exist, throw  {{NotFoundError}} and stop.
              </li>
              <li>
                Let |handler:function| be `null`.
              </li>
              <li>
                If there is a user provided {{PropertyReadHandler}} in {{ExposedThing/[[readHandlers]]}} <a>internal slot</a>
                for |interaction|, let |handler| be that.
              </li>
              <li>
                Otherwise, if there is a default read handler provided by the implementation, let |handler| be that.
              </li>
              <li>
                If |handler| is `null`, throw {{NotSupportedError}}
                and stop.
              </li>
              <li>
                Let |value| be the result of invoking |handler| given |options|.
                If that fails, throw the error and stop.
              </li>
              <li>
                Return |value|.
                <p class="note">
                  The |value| returned here SHOULD either conform to <a>DataSchema</a>
                  or it SHOULD be an {{ReadableStream}} object created by the
                  |handler|.
                </p>
              </li>
            </ol>
          </li>
          <li>
            If the previous step has thrown an error, send the error back with
            the reply created by following the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Serialize and add the returned |value| to the reply created by
            following the <a>Protocol Bindings</a>.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling requests for reading multiple Properties</h3>
      <div>
        When a network request for reading multiple <a>Properties</a> given in
        an object |propertyNames| is received with |options:InteractionOptions|,
        run the following <dfn>read multiple properties</dfn> steps on |propertyNames| and |options|:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            For each property with key |name| defined in |propertyNames|,
            <ol>
              <li>
                Let |value| be the result of running the <a>read server property</a>
                steps on |name| and |options|.
                If that throws, send back the error in the reply created by following the  <a>Protocol Bindings</a> and stop.
              </li>
              <li>
                Set |propertyNames|.|name| to |value|.
              </li>
            </ol>
          </li>
          <li>
            Reply to the request by sending a single reply created from |propertyNames| according to the <a>Protocol Bindings</a>.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling requests for reading all Properties</h3>
      <div>
        When a network request for reading all <a>Properties</a> is received
        with |options:InteractionOptions|, run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |properties| be an object created with all properties defined in
            the <a>Thing</a> with values set to `null`.
          </li>
          <li>
            Run the <a>read multiple properties</a> steps on |properties| and
            |options|.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>The <dfn>setPropertyObserveHandler()</dfn> method</h3>
      <p>
        Takes as arguments |name:string| and |handler:PropertyReadHandler|.
        Sets the service handler that defines what to do when a request is received
        for observing the specified <a>Property</a> matched by |name|.
        Throws on error.
        Returns a reference to |this| object for supporting chaining.
      </p>
      <p>
         The |handler| callback function should implement reading a
         <a>Property</a> and [=resolve=] with an {{InteractionOutput}} object or
         [=reject=] with an error.
      </p>
      <p>
        There MUST be at most one handler for any given <a>Property</a>, so newly added handlers MUST replace the previous handlers. If no handler is initialized for any given <a>Property</a>, implementations SHOULD implement a default property read handler based on the <a>Thing Description</a>.
      </p>
      <div>
        When the method is invoked given |name:string| and
        |handler:PropertyReadHandler|, implementations MUST run the
        following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>
            If |this|.{{ExposedThing/[[td]]}}.|properties|[|name|] does not [=map/exist=],
            [= exception/throw =] {{NotFoundError}} and stop.
          </li>
          <li>
            Set |this|{{ExposedThing/[[observeHandlers]]}}[|name|] to |handler|.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling <a>Property</a> observe requests</h3>
      <div>
        When a network request for observing a <a>Property</a> |name:string| is
        received by the implementation with |options:InteractionOptions|,
        run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If |this|.{{ExposedThing/[[td]]}}.|properties|[|name|] does not
            [=map/exist=], send back a {{NotFoundError}} in the
            reply and stop.
          </li>
          <li>
            Internally save the request sender information together with |options| and
            |this|.{{ExposedThing/[[propertyObservers]]}}[|name|], in order to be able
            to notify about <a>Property</a> value changes.
          </li>
        </ol>
      </div>
      <p class=note>
        Every time the value of |property| changes,
        <a href="#the-emitpropertychange-method">`emitPropertyChange()`</a>
        needs to be explicitly called by the application script.
      </p>
    </section>

    <section> <h3>The <dfn>setPropertyUnobserveHandler()</dfn> method</h3>
      <p>
        Takes as arguments |name:string| and |handler:PropertyReadHandler|.
        Sets the service handler that defines what to do when a request is
        received for unobserving the specified <a>Property</a> matched by |name|.
        Throws on error.
        Returns a reference to |this| object for supporting chaining.
      </p>
      <p>
        The |handler| callback function should implement what to do when an
        unobserve request is received by the implementation.
      </p>
      <p>
        There MUST be at most one handler for any given <a>Property</a>, so newly added handlers MUST replace the previous handlers. If no handler is initialized for any given <a>Property</a>, implementations SHOULD implement a default handler based on the <a>Thing Description</a>.
      </p>
      <div>
        When the method is invoked given |name:string| and
        |handler:PropertyReadHandler|, implementations MUST run the
        following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a
            {{SecurityError}} and stop.
          </li>
          <li>
            If |this|.{{ExposedThing/[[td]]}}.|properties|[|name|] does not [=map/exist=],
            [= exception/throw =] {{NotFoundError}} and stop.
          </li>
          <li>
            Set |this|.{{ExposedThing/[[unobserveHandlers]]}}[|name|] to |handler|.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling <a>Property</a> unobserve requests</h3>
      <div>
        When a network request for unobserving a <a>Property</a> |name:string|
        with |options:InteractionOptions| is received by the implementation,
        run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If |this|.{{ExposedThing/[[td]]}}.|properties|[|name|] does not [=map/exist=],
            send back a {{NotFoundError}} in the reply and stop.
          </li>
          <li>
            Let |handler| be |this|.{{ExposedThing/[[unobserveHandlers]]}}[|name|];
          </li>
          <li>
            If |handler| is a {{Function}}, invoke that given |options|, then send back a
            reply following the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Otherwise, if |this|.{{ExposedThing/[[propertyObservers]]}}[|name|] [=map/exists=],
            remove it from |this|.{{ExposedThing/[[propertyObservers]]}}, send back a reply as defined in the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Otherwise, send back a {{NotFoundError}} in the reply as defined in
            the <a>Protocol Bindings</a> and stop.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>The <dfn>emitPropertyChange()</dfn> method</h3>
      <div>
        Takes the |name:string| argument, denoting a <a>Property</a> name, and
        optionally the |data:InteractionInput| argument.
        Triggers emitting a notification to all observers of the specified
        <a>Property</a> with the data provided by the |data| argument, or if not
        provided, it is obtained by the observe handler or the by
        read handler associated with that <a>Property</a>.
        The method MUST run the following steps:
        <ol>
          <li>Let |promise:Promise| be a new {{Promise}}.
          <li>
            Return |promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            Let |name| be the first argument.
          </li>
          <li>
            Let |property| be |this|.{{ExposedThing/[[td]]}}.|properties|[|name|].
          </li>
          <li>
            If |property| is `undefined`,
            [=reject=] |promise| with {{NotFoundError}} and stop.
          </li>
		  <!--
			Do we need a dedicated emitPropertChange handler instead of using readHandler?
			see https://github.com/w3c/wot-scripting-api/issues/407
		  -->
          <li>
            Let |data| be the second argument.
          </li>
          <li>
            If |data| is `undefined`, run the following sub-steps:
            <ol>
              <li>
                Let |handler:function| be `null.`
              </li>
              <li>
                If |name| does not [=map/exist=] in {{ExposedThing/[[readHandlers]]}},
                [=reject=] |promise| and stop.
              </li>
              <li>
                Let |handler| be {{ExposedThing/[[readHandlers]]}}[|name|].
              </li>
              <li>
                If |handler| is `null` or `undefined`, [=reject=] |promise| and stop.
              </li>
              <li>
                Let |handled| be the result of invoking |handler| given `null`.
              </li>
              <li>
                 If |handled| is [=rejected=], then [=reject=] |promise| and stop.
              </li>
              <li>
                Otherwise if |handled| [=resolved=] with |value|, let |data| be |value|.
            </ol>
          </li>
          <li>
            For each |observer| in {{ExposedThing/[[propertyObservers]]}}[|name|],
            run the following sub-steps:
            <ol>
              <li>
                Let |options| be the interaction options saved with |observer|.
              </li>
              <li>
                Request the underlying platform to create a |reply| from |data| and |options| according to the <a>Protocol Bindings</a>.
                <p class="ednote">
                  This clause needs expanding and/or refer to an algorithm in [[WOT-PROTOCOL-BINDINGS]].
                </p>
              </li>
              <li>
                Send |reply| to |observer|.
              </li>
            </ol>
          </li>
          <li>
            [=Resolve=] |promise|.
          </li>
        </ol>
        </ol>
      </div>
    </section>

    <section data-dfn-for="PropertyWriteHandler">
      <h3>The <dfn>PropertyWriteHandler</dfn> callback</h3>
      <p>
        A function that is called when an external request for writing a
        <a>Property</a> is received and defines what to do with such requests.
        Takes as argument |value:InteractionOutput| and returns a {{Promise}},
        resolved when the value of the <a>Property</a> - identified by the name
        provided when setting the handler has been updated -, or rejects
        with an error if the property is not found or the value cannot be updated.
      </p>
      <p class="ednote">
        Note that the code in this callback function can read the property before updating it in order to find out the old value, if needed. Therefore the old value is not provided to this function.
      </p>
      <p class="note">
        The value is provided by implementations as an {{InteractionOutput}} object
        in order to be able to represent values that are not described by a
        <a>DataSchema</a>, such as streams.
      </p>
    </section>

    <section> <h3>The <dfn>setPropertyWriteHandler()</dfn> method</h3>
      <p>
        Takes as arguments |name:string| and |handler:PropertyWriteHandler|.
        Sets the service handler that defines what to do when a request is
        received for writing the <a>Property</a> matched by |name| given when
        setting the handler.
        Throws on error.
        Returns a reference to |this| object for supporting chaining.
      </p>
      <p class="note">
        Note that even for readonly <a>Properties</a> it is possible to specify
        a write handler, as explained in <a href="https://github.com/w3c/wot-scripting-api/issues/199">Issue 199</a>. In this case, the write
        handler may define in an application-specific way to fail the request.
      </p>
      <p>
        There MUST be at most one write handler for any given <a>Property</a>, so newly added handlers MUST replace the previous handlers. If no write handler is initialized for any given <a>Property</a>, implementations SHOULD implement default property update if the <a>Property</a> is
        writeable and notifying observers on change if the <a>Property</a> is
        observable, based on the <a>Thing Description</a>.
      </p>
      <div>
        When the method is invoked given |name:string| and
        |handler:PropertyWriteHandler|, implementations MUST run the
        following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>
            If |this|.{{ExposedThing/[[td]]}}.|properties|[|name|] does not [=map/exist=],
            [= exception/throw =] {{NotFoundError}} and stop.
          </li>
          <li>
            Set |this|.{{ExposedThing/[[writeHandlers]]}}[|name|] to |handler|.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling requests for writing a Property</h3>
      <div>
        When a network request for writing a <a>Property</a> |name:string|
        with a new value |value:InteractionOutput| and |options:InteractionOptions|
        is received, implementations MUST run the following
        <dfn>update property steps</dfn>, given |name|, |value|, |options|
        and |mode| set to `"single"`:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ExposedThing/[[td]]}}.|properties|[|name|].
          </li>
          <li>
            If |interaction| is `undefined`, return a {{NotFoundError}} in the
            reply and stop.
          </li>
          <li>
            Let |handler:function| be |this|.{{ExposedThing/[[writeHandlers]]}}[|name|].
          </li>
          <li>
            If |handler| is `undefined` and if there is a default write handler provided by the implementation, let |handler| be that.
          </li>
          <li>
            If |handler| is `undefined`, send back a {{NotSupportedError}}
            with the reply and stop.
          </li>
          <li>
            Let |promise| be the result of invoking |handler| given |name| and
            |options|. If it fails, return the error in the reply and stop.
          </li>
          <li>
            If |mode| is `"single"`, reply to the request reporting success, following the <a>Protocol Bindings</a> and stop.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling requests for writing multiple Properties</h3>
      <div>
        When a network request for writing multiple <a>Properties</a> given in an object |propertyNames| is received with |options:InteractionOptions|,
        run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            For each property with key |name| and value |value| defined in |propertyNames|, run the <a>update property steps</a> with |name|, |value|, |options| and |mode| set to `"multiple"`.
            If that fails, reply to the request with that error and stop.
          </li>
          <li>
            Reply to the request by sending a single reply according to the
            <a>Protocol Bindings</a>.
          </li>
        </ol>
      </div>
    </section>

    <section data-dfn-for="ActionHandler">
      <h3>The <dfn>ActionHandler</dfn> callback</h3>
      <p>
        A function that is called when an external request for invoking an
        <a>Action</a> is received and defines what to do with such requests.
        It is invoked given |params:InteractionOutput| and optionally
        with an |options:InteractionOptions| object.
        It returns a {{Promise}} that rejects with an error or resolves with
        the value returned by the <a>Action</a> as {{InteractionInput}}.
      </p>
      <p class="note">
        Application scripts MAY return a {{ReadableStream}} object from an
        {{ActionHandler}}. Implementations will then use the stream for
        constructing the <a>Action</a>'s response.
      </p>
    </section>

    <section> <h3>The <dfn>setActionHandler()</dfn> method</h3>
      <p>
        Takes as arguments |name:string| and |action:ActionHandler|.
        Sets the handler function that defines what to do when a request is
        received to invoke the <a>Action</a> matched by |name|.
        Throws on error.
        Returns a reference to |this| object for supporting chaining.
      </p>
      <p>
         The |action| callback function will implement an <a>Action</a> and SHOULD be called by implementations when a request for invoking the <a>Action</a> is received from the underlying platform.
      </p>
      <p>
        There MUST be at most one handler for any given <a>Action</a>, so newly added handlers MUST replace the previous handlers.
      </p>
      <div>
        When the method is invoked given |name:string| and |action:ActionHandler|,
        run the following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ExposedThing/[[td]]}}.|actions|[|name|].
          </li>
          <li>
            If |interaction| is `undefined`,
            [= exception/throw =] a {{NotFoundError}} and stop.
          </li>
          <li>
            Set |this|.{{ExposedThing/[[actionHandlers]]}}[|name|] to |action|.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling <a>Action</a> requests</h3>
      <div>
        When a network request for invoking the <a>Action</a> identified by |name:string| is received given |inputs| and optionally |options:InteractionOptions|, run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ExposedThing/[[td]]}}.|properties|[|name|].
          </li>
          <li>
            If |interaction| is `undefined`, return a {{NotFoundError}} in the reply and stop.
          </li>
          <li>
            Let |handler:function| be |this|.{{ExposedThing/[[actionHandlers]]}}[|name|].
          </li>
          <li>
            If |handler| is `undefined`, return a {{NotSupportedError}} with the reply
            created by following the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |promise| be the result of invoking |handler| given |name|, |inputs| and |options|.
          </li>
          <li>
            If |promise| rejects, send the error with the reply and stop.
          </li>
          <li>
            When |promise| resolves with |data:InteractionInput|, use |data| to
            create and send the reply according to the <a>Protocol Bindings</a>.
          </li>
        </ol>
      </div>
    </section>

    <section data-dfn-for="EventSubscriptionHandler">
      <h3>The <dfn>EventSubscriptionHandler</dfn> callback</h3>
      <p>
        A function that is called when an external request for subscribing to an
        <a>Event</a> is received and defines what to do with such requests.
        It is invoked given an |options:InteractionOptions| object provided by the implementation and coming from subscribers.
        It returns a {{Promise}} that rejects with an error or resolves when
        the subscription is accepted.
      </p>
    </section>

    <section> <h3>The <dfn>setEventSubscribeHandler()</dfn> method</h3>
      <p>
        Takes as arguments |name:string| and |handler:EventSubscriptionHandler|.
        Sets the handler function that defines what to do when a subscription
        request is received for the specified <a>Event</a> matched by |name|.
        Throws on error.
        Returns a reference to |this| object for supporting chaining.
      </p>
      <p>
         The |handler| callback function SHOULD implement what to do when an
         subscribe request is received, for instance necessary initializations.
         Note that the handler for emitting <a>Events</a> is set separately.
      </p>
      <p>
        There MUST be at most one event subscribe handler for any given
        <a>Event</a>, so newly added handlers MUST replace the previous handlers.
      </p>
      <div>
        When the method is invoked given |name:string| and
        |handler:EventSubscriptionHandler|, run the following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ExposedThing/[[td]]}}.|events|[|name|].
          </li>
          <li>
            If |interaction| is `undefined`,
            [= exception/throw =] a {{NotFoundError}} and stop.
          </li>
          <li>
            Set |this|.{{ExposedThing/[[subscribeHandlers]]}}[|name|] to |handler|.
          </li>
          <li>
            Return `this`.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling <a>Event</a> subscribe requests</h3>
      <div>
        When an <a>Event</a> subscription request for |name| is received by the
        underlying platform with optional |options:InteractionOptions|,
        run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ExposedThing/[[td]]}}.|events|[|name|].
          </li>
          <li>
            If |interaction| is `undefined`, send back a
            {{NotFoundError}} and stop.
          </li>
          <li>
            If |this|.{{ExposedThing/[[subscribeHandlers]]}}[|name|] is a {{Function}},
            invoke it given |options| and stop.
          </li>
          <li>
            Otherwise implement the default subscriber mechanism:
            <ol>
              <li>
                Let |subscriber| be a tuple formed of |options| (from which
                |uriVariables| and |data| may be used) and the
                subscriber information needed to create an <a>Event</a>
                notification response.
              </li>
              <li>
                Set |this|.{{ExposedThing/[[eventListeners]]}}[|name|] to |subscriber|.
              </li>
            </ol>
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>The <dfn>setEventUnsubscribeHandler()</dfn> method</h3>
      <p>
        Takes as arguments |name:string| and |handler:EventSubscriptionHandler|.
        Sets the handler function that defines what to do when the specified
        <a>Event</a> matched by |name| is unsubscribed from.
        Throws on error.
        Returns a reference to |this| object for supporting chaining.
      </p>
      <p>
         The |handler| callback function SHOULD implement what to do when an
         unsubscribe request is received.
      </p>
      <p>
        There MUST be at most one handler for any given <a>Event</a>, so newly added handlers MUST replace the previous handlers.
      </p>
      <div>
        When the method is invoked given |name:string| and
        |handler:EventSubscriptionHandler|, run the following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ExposedThing/[[td]]}}.|events|[|name|].
          </li>
          <li>
            If |interaction| is `undefined`,
            [= exception/throw =] a {{NotFoundError}} and stop.
          </li>
          <li>
            Set |this|.{{ExposedThing/[[unsubscribeHandlers]]}}[|name|] to |handler|.
          </li>
          <li>
            Return `this`.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling <a>Event</a> unsubscribe requests</h3>
      <div>
        When an <a>Event</a> unsubscribe request for |name| is received by the
        underlying platform optionally with |options:InteractionOptions|,
        run the following steps:
        <ol>
          <li>
            If this operation is not supported, send back a {{NotSupportedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            If this operation is not allowed, send back a {{NotAllowedError}}
            according to the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Let |interaction| be |this|.{{ExposedThing/[[td]]}}.|events|[|name|].
          </li>
          <li>
            If |interaction| is `undefined`, send back a
            {{NotFoundError}} and stop.
          </li>
          <li>
            If |this|.{{ExposedThing/[[unsubscribeHandlers]]}}[|name|]
            [=map/exists=] and is a {{Function}}, invoke it given |options| and stop.
          </li>
          <li>
            Otherwise |name| [=map/exists] in |this|.{{ExposedThing/[[eventListeners]]}},
            [=map/remove=] |name|.
          </li>
          <li>
            Return `this`.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>Handling <a>Events</a></h3>
      <div>
        When an <a>Event</a> with name |name| is emitted with
        |data:InteractionInput| by the
        <a href="#the-emitevent-method">emitEvent()</a> method, run the
        following steps:
        <ol>
          <li>
            Let |listeners| be {{ExposedThing/[[eventListeners]]}}.|name|.
          </li>
          <li>
            For each |subscriber| in |listeners|, run the following sub-steps:
            <ol>
              <li>
                Create an <a>Event</a> notification |response| according to the
                <a>Protocol Bindings</a> from |data| and |subscriber|, including
                its |options|.
              </li>
              <li>
                  If |data| is `undefined`, assume that the notification |response|
                  will contain an empty data payload as specified by <a>Protocol Bindings</a>.
              </li>
              <li>
                If the underlying protocol stack permits conveying event errors and
                if an error condition has been detected by the UA, create |response|
                as an error notification according to the <a>Protocol Bindings</a>,
                using |data|, |subscriber| and its |options|.
                <p class="note">
                  The error reporting is protocol specific and it is encapsulated by
                  implementations. On the client end, the error listener passed with
                  the subscription will be invoked if the client UA detects the error.
                </p>
              </li>
              <li>
                Send |response| to the subscriber identified by |subscriber|.
              </li>
            </ol>
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>The <dfn>emitEvent()</dfn> method</h3>
      <div>
        Takes as arguments |name:string| denoting an <a>Event</a> name and
        optionally |data:InteractionInput|.
        Triggers emitting the <a>Event</a> with the optional data.
        The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            Let |interaction| be {{ExposedThing/[[td]]}}.|events|.|name|.
          </li>
          <li>
            If an <a>Event</a> with the name |name| is not found,
            [=reject=] |promise| with {{NotFoundError}} and stop.
          </li>
          <li>
            Make a request to the underlying platform to emit an <a>Event</a>
            with optional |data|. Call the <a href="#handling-events">handling events</a>
            steps.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>The <dfn>expose()</dfn> method</h3>
      <div>
        Start serving external requests for the <a>Thing</a>, so that <a>WoT Interactions</a> using <a>Properties</a>, <a>Action</a>s and <a>Event</a>s will be possible. The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            Run the <a>expand a TD</a> steps on the {{ExposedThing/[[td]]}}.
          </li>
          <li>
            Run the <a>validate a TD</a> on {{ExposedThing/[[td]]}}. If that fails,
            [=reject=] |promise| with a {{TypeError}} and stop.
          </li>
          <li>
            For each |key| in {{ExposedThing/[[td]]}}.|properties| initialize
            |this|.{{ExposedThing/[[propertyObservers]]}}.|key| to an empty {{Array}}
            in order to store observe request data needed to notify the observers on value changes.
          </li>
          <li>
            For each |key| in |this|.{{ExposedThing/[[td]]}}.|events| initialize
            |this|.{{ExposedThing/[[eventListeners]]}}.|key| to an empty {{Array}}
            in order to store subscribe request data needed to notify the subscribers on event emission.
          </li>
          <li>
            Set up the <a>WoT Interactions</a> based on introspecting {{ExposedThing/[[td]]}}
            as explained in [[!WOT-TD]] and [[!WOT-PROTOCOL-BINDINGS]].
            Make a request to the underlying platform to initialize the
            <a>Protocol Bindings</a> and then start serving external requests
            for <a>WoT Interactions</a> (read, write and observe <a>Properties</a>,
            invoke <a>Action</a>s and manage <a>Event</a> subscriptions),
            based on the <a>Protocol Bindings</a>.
            Implementations MAY reject this step for any reason (e.g. if they
            want to enforce further checks and constraints on interaction forms).
          </li>
          <li>
            If there was an error during the request, [=reject=] |promise| with an {{Error}} object |error| with |error|.|message| set to the error code seen by the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Otherwise [=resolve=] |promise| and stop.
          </li>
        </ol>
      </div>
    </section>

    <section> <h3>The <dfn>destroy()</dfn> method</h3>
      <div>
        Stop serving external requests for the <a>Thing</a> and destroy the object. Note that eventual unregistering should be done before invoking this method. The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [=reject=] |promise| with a {{SecurityError}} and stop.
          </li>
          <li>
            Make a request to the underlying platform to stop serving external requests for <a>WoT Interactions</a>, based on the <a>Protocol Bindings</a>.
          </li>
          <li>
            If there was an error during the request, [=reject=] |promise| with an {{Error}} object |error| with its |message| set to the error code seen by the <a>Protocol Bindings</a> and stop.
          </li>
          <li>
            Otherwise [=resolve=] |promise| and stop.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h2>ExposedThing Examples</h2>
      <p>
        The next example illustrates how to create an {{ExposedThing}} based on a partial <a>TD</a> object constructed beforehand.
      </p>
      <pre class="example highlight" title="Create ExposedThing with a simple Property">
        try {
          let temperaturePropertyDefinition = {
            type: "number",
            minimum: -50,
            maximum: 10000
          };
          let tdFragment = {
            properties: {
              temperature: temperaturePropertyDefinition
            },
            actions: {
              reset: {
                description: "Reset the temperature sensor",
                input: {
                  temperature: temperatureValueDefinition
                },
                output: null,
                forms: []
              },
            },
            events: {
              onchange: temperatureValueDefinition
            }
          };
          let thing1 = await WOT.produce(tdFragment);
          // initialize Properties
          await thing1.writeProperty("temperature", 0);
          // add service handlers
          thing1.setPropertyReadHandler("temperature", () => {
             return readLocalTemperatureSensor();  // Promise
          });
          // start serving requests
          await thing1.expose();
        } catch (err) {
           console.log("Error creating ExposedThing: " + err);
        }
      </pre>

      <p>
        The next example illustrates how to add or modify a <a>Property</a> definition on an existing {{ExposedThing}}: take its |td| property, add or modify it, then create another {{ExposedThing}} with that.
      </p>
      <pre class="example highlight" title="Add an object Property">
        try {
          // create a deep copy of thing1's TD
          let instance = JSON.parse(JSON.stringify(thing1.td));
          const statusValueDefinition = {
            type: "object",
            properties: {
              brightness: {
                type: "number",
                minimum: 0.0,
                maximum: 100.0,
                required: true
              },
              rgb: {
                type: "array",
                "minItems": 3,
                "maxItems": 3,
                items : {
                    "type" : "number",
                    "minimum": 0,
                    "maximum": 255
                }
              }
          };
          instance["name"] = "mySensor";
          instance.properties["brightness"] = {
            type: "number",
            minimum: 0.0,
            maximum: 100.0,
            required: true,
          };
          instance.properties["status"] = statusValueDefinition;
          instance.actions["getStatus"] = {
            description: "Get status object",
            input: null,
            output: {
              status : statusValueDefinition;
            },
            forms: [...]
          };
          instance.events["onstatuschange"] = statusValueDefinition;
          instance.forms = [...];  // update
          var thing2 = new ExposedThing(instance);
          // TODO: add service handlers
          await thing2.expose();
          });
        } catch (err) {
           console.log("Error creating ExposedThing: " + err);
        }
      </pre>
      <p>
        The following will cover a set of examples for the generation of a <a>Thing Description</a> from
        an <a>ExposedThingInit</a> using <a>expand an ExposedThingInit</a> steps. As hypothesis the runtime
        supports HTTP and COAP protocol bindings and it is hosted at 192.168.0.1.
      </p>
      <p>
        The next example shows how to exploit a <a>ExposedThingInit</a> to create a simple <a>Thing Description</a>
        with one <a>Property</a> with the default values.
      </p>
      <aside class="example ds-selector-tabs" title="Create a Thing Description with one Property affordance">
        <div class="selectors">
          <button class="selected" data-selects="init">ExposedThingInit</button>
          <button data-selects="td">ThingDescription</button>
        </div>

        <pre class="selected init" data-transform="updateExample" title="An instance of the ExposedThingInit type">
          {
            "properties" : {
              "temperature":{}
            }
          }
        </pre>
        <pre class="td" data-transform="updateExample" >
          {
            "@context": [
              "https://www.w3.org/2019/wot/td/v1"
            ],
            "title": "Thing-123",
            "securityDefinitions": {
              "no_sec": {
                "scheme": "nosec"
              }
            },
            "security": "no_sec",
            "properties": {
              "temperature": {
                "forms": [{
                  "href": "http://192.168.0.1:8080/properties/temperature",
                  "contentType": "application/json"
                },
                {
                "href": "coap://192.168.0.1:9090/properties/temperature",
                "contentType": "application/json"
                }]
              }
            }
          }
        </pre>
      </aside>
     <p class="ednote">
       TODO: add more examples where the <a>ExposedThingInit</a> contains suggested values that are replaced by the algorithm.
     </p>
    </section> <!-- ExposedThing Examples -->
  </section> <!-- ExposedThing -->

  <section data-cite="webidl" data-dfn-for="ThingDiscoveryProcess">
    <h2>The <dfn>ThingDiscoveryProcess</dfn> interface</h2>
    <p>
      Discovery is a distributed application that requires provisioning and support from participating network nodes (clients, servers, directory services). This API models the client side of typical discovery schemes supported by various IoT deployments.
    </p>
    <p>
      The {{ThingDiscoveryProcess}} object provides the properties and methods
      controlling the discovery process and returning the results.
    </p>
    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ThingDiscoveryProcess {
        constructor(optional ThingFilter filter = {});
        readonly attribute boolean done;
        readonly attribute Error? error;
        undefined stop();
        async iterable&lt;ThingDescription&gt;;
      };
    </pre>
    <p>
      The {{ThingDiscoveryProcess}} object has the following <a>internal slot</a>s.
    </p>
    <table class="simple">
      <thead>
       <tr>
        <th>Internal Slot</th>
        <th>Initial value</th>
        <th>Description (<em>non-normative</em>)</th>
       </tr>
      </thead>
      <tbody data-link-for="ThingDiscoveryProcess">
       <tr>
        <td><dfn>[[\filter]]</dfn></td>
        <td>`undefined`</td>
        <td>The {{ThingFilter}} object used in discovery.</td>
       </tr>
      <tr>
        <td><dfn>[[\url]]</dfn></td>
        <td>`undefined`</td>
        <td>A {{URL}} representing the <a>TD Directory</a> in a discovery.</td>
      </tr>
      </tbody>
    </table>
    <p>
      The <dfn>done</dfn> property is `true` if the discovery has been stopped
      or completed with no more results to report.
    </p>
    <p>
      The <dfn>error</dfn> property represents the last error that occurred during the discovery process. Typically used for critical errors that stop discovery.
    </p>
    <p>
      The {{ThingDiscoveryProcess}} object implements the
      <a data-cite="ECMASCRIPT#sec-symbol.asynciterator">async iterator</a>
      concept.
    </p>

    <section><h3>Constructing {{ThingDiscoveryProcess}}</h3>
      <div>
        To create {{ThingDiscoveryProcess}} with a |filter:ThingFilter|, run the following steps:
        <ol>
          <li>
            If |filter| is not an object or `null`, [= exception/throw =] a {{TypeError}} and stop.
          </li>
          <li>
            Let |discovery:ThingDiscoveryProcess| be a new {{ThingDiscoveryProcess}} object.
          </li>
          <li>
            Set |discovery|.{{ThingDiscoveryProcess/[[filter]]}} to |filter|.
          </li>
          <li>
            Set |discovery|.{{ThingDiscoveryProcess/done}} to `false`.
          </li>
          <li>
            Set |discovery|.{{ThingDiscoveryProcess/error}} to `null`.
          </li>
          <li>
            Return |discovery|.
          </li>
        </ol>
      </div>
    </section>

    <section data-dfn-for="ThingFilter">
      <h3>The <dfn>ThingFilter</dfn> dictionary</h3>
      <p>
        Represents an object containing the constraints for discovering <a>Thing</a>s as key-value pairs.
      </p>
      <pre class="idl">
        dictionary ThingFilter {
          object? fragment;
          <!-- DOMString? query; -->
        };
      </pre>
      <p>
        The <dfn>fragment</dfn> property represents a template object used for matching property by property against discovered <a>Thing</a>s.
      </p>
      <p class = "ednote">
        The |query:DOMString| property was temporarily removed from
        <a>ThingFilter</a>, until it is standardized in the WoT Discovery
        task force. It represented a query string accepted by the implementation,
        for instance a SPARQL or JSON query. Support was to be implemented locally
        in the <a>WoT Runtime</a> or remotely as a service in a <a>TD Directory</a>.
      </p>
      <p class="ednote">
        The |url:USVString| property was removed. It used to represent the target
        entity serving the discovery request, for instance the URL of a
        <a>TD Directory</a>, or the URL of a directly targeted <a>Thing</a>,
        but these are implemented by dedicated methods now.
      </p>
    </section>

    <section>
      <h3>The <dfn data-lt="discovery-process">discovery process</dfn> algorithm</h3>
      <div>
        Describes what to do during a discovery process that has already started.
        The algorithm, given |discovery:ThingDiscoveryProcess|, runs the following steps:
        <ol>
          <li>
            Whenever a new |link| to a <a>Thing Description</a>
            is discovered and provided by the underlying platform, run the following
            sub-steps:
            <ol>
              <li>
                Retrieve |td:ThingDescription| as a JSON object, using the <a>Protocol Binding</a>
                used by the underlying discovery process (as specified by |link|).
                In the case of an HTTP(S) Binding, this process could use the
                <a data-cite="fetch#fetch-api">Fetch API</a>
                for the |td|'s retrieval.
              </li>
              <li>
                If that fails, set the |discovery|.{{ThingDiscoveryProcess/error}}
                property to {{SyntaxError}}, discard |td| and continue the discovery process.
              </li>
            </ol>
          </li>
          <li>
            Whenever a <a>Thing Description</a> |td| is discovered and provided
            by the underlying platform or by the previous step, run the following
            sub-steps:
            <p class="note">
              At this point implementations MAY control the flow of the discovery
              process (depending on memory constraints, for instance queue the
              results, or temporarily stop discovery if the queue is getting too
              large, or resume discovery when the queue is emptied sufficiently).
              These steps are run for each discovered/fetched |td|.
            </p>
            <ol>
              <!--li>
                If |filter|'s <a href="#dom-thingfilter-query">|query|</a> is defined, check if |json| is a match for the query. The matching algorithm is encapsulated by implementations. If that returns `false`, discard |td| and continue the discovery process.
              </li-->
              <li>
                Let |fragment| be |discovery|.{{ThingDiscoveryProcess/[[filter]]}}.{{ThingFilter/fragment}}.
              </li>
              <li>
                If |fragment| is an {{object}}, then for each |key| defined in it:
                <ol>
                  <li>
                     Check if that |key| [=map/exists=] in |json| and |json|[|key| is equal to |fragment|.|key|.
                  </li>
                  <li>
                    If this is fails in any checks, discard |td| and continue the discovery process.
                  </li>
                </ol>
              </li>
              <li>
                Yield |td| using {{Symbol/asyncIterator}}.
                <p class="ednote">
                  Improve this step using proper asyncIterator terminology.
                </p>
              </li>
            </ol>
          </li>
          <li>
            Whenever an error occurs during the discovery process, run the following
            sub-steps:
            <p class="note">
              The last error is retained. Implementations MAY choose to stop the
              discovery process if they consider it should be reported.
            </p>
            <ol>
              <li>
                Let |error| be a new {{Error}} object.
                Set |error|.|name| to `"DiscoveryError"`.
              </li>
              <li>
                 If there was an error code or message provided by the
                 <a>Protocol Bindings</a>, set |error|.|message| to that value as string.
              </li>
              <li>
                Set |discovery|.{{ThingDiscoveryProcess/error}} to |error|.
              </li>
              <li>
                If the error is irrecoverable and discovery has been stopped by
                the underlying platform, or if the implementation decided to
                stop the discovery process and report the error, set
                |discovery|.{{ThingDiscoveryProcess/done}} to `true` and
                terminate these steps.
              </li>
            </ol>
          </li>
        </ol>
      </div>
   </section>
<!--
    <section>
      <h3>The <dfn>next()</dfn> method of {{Symbol/asyncIterator}}</h3>
      <div>
        Provides the next discovered {{ThingDescription}} object. The method MUST run the following steps:
        <ol>
          <li>
            Return a {{Promise}} |promise:Promise| and execute the next steps [=in parallel=].
          </li>
          <li>
            Call the `next` method on the Discovery object's {{Symbol/asyncIterator}}.
          </li>
          <li>
            If the `value` property in the yielded result from the {{Symbol/asyncIterator}} is undefined, set the
            {{ThingDiscoveryProcess/done}} property to `true` and [=reject=] |promise|.
          </li>
          <li>
            [=Resolve=] |promise| with |td| and stop.
          </li>
        </ol>
      </div>
    </section>
-->
    <section>
      <h3>The <dfn>stop()</dfn> method</h3>
      <div>
        Stops or suppresses the discovery process. It might not be supported by all discovery methods and endpoints, however, any further discovery results or errors will be discarded and the discovery is marked as done. The method MUST run the following steps:
        <ol>
          <li>
            If invoking this method is not allowed for the current scripting context for security reasons, [= exception/throw =] a {{SecurityError}} and stop.
          </li>
          <li>
            Request the underlying platform to stop the discovery process. If this returns an error, or if it is not possible, for instance when discovery is based on open ended multicast requests, the implementation SHOULD discard subsequent discovered items.
          </li>
          <li>
            Set the {{ThingDiscoveryProcess/done}} property to `true`.
          </li>
        </ol>
      </div>
    </section>

    <section>
      <h3>Discovery Examples</h3>
      <p>
        The following example finds {{ThingDescription}} objects of <a>Thing</a>s that are exposed by local hardware, regardless how many instances of <a>WoT Runtime</a> it is running
        Using the {{Symbol/asyncIterator}} provided by the Discovery object, we can iterate asynchronously over the results and perform operations with the obtained {{ThingDescription}} objects.
      </p>
      <pre class="example" title="Fetch the Thing Description of a Thing">
        let url = "https://mythings.com/thing1";
        let td = await WOT.requestThingDescription(url);
        console.log("Found Thing Description for " + td.title);
      </pre>
      <p>
        The next example finds {{ThingDescription}} objects of <a>Thing</a>s listed in a <a>TD Directory</a> service. We set a timeout for safety.
      </p>
      <pre class="example" title="Discover Things via directory">
        let discovery = await WOT.exploreDirectory("http://directory.wotservice.org");
        setTimeout( () => {
            discovery.stop();
            console.log("Discovery stopped after timeout.");
          },
          3000);
        for await (const td of discovery) {
          console.log("Found Thing Description for " + td.title);
          let thing = new ConsumedThing(td);
          console.log("Thing name: " + thing.getThingDescription().title);
        };
        if (discovery.error) {
          console.log("Discovery stopped because of an error: " + error.message);
        }
      </pre>
      <p>
        The next example is for a generic discovery, by any means provisioned
        to the WOT runtime, including local Things, if any is available.
      </p>
      <pre class="example" title="Discover Things in a network">
        let discovery = await WOT.discover();
        setTimeout( () => {
            discovery.stop();
            console.log("Stopped open-ended discovery");
          },
          10000);
        for await (const td of discovery) {
          console.log("Found Thing Description for " + td.title);
        };
        if (discovery.error) {
          console.log("Discovery stopped because of an error: " + error.message);
        }
      </pre>
    </section> <!-- Examples -->
  </section>

  <section> <h2 id="security">Security and Privacy</h2>
    <p>
      A detailed discussion of security and privacy considerations for the Web of Things, including a threat model that can be adapted to various circumstances, is
      presented in the informative document [[!WOT-SECURITY]].
      This section discusses only security and privacy risks and possible mitigations
      directly relevant to the scripts and WoT Scripting API.
    </p>
    <p>
      A suggested set of best practices to improve security for WoT devices and
      services has been documented in [[!WOT-SECURITY]].
      That document may be updated as security measures evolve.
      Following these practices does not guarantee security,
      but it might help avoid commonly known vulnerabilities.
    </p>
    <div>
      The WoT security risks and possible mitigations are concerning the following groups:
      <ul>
        <li>
          Implementors of WoT Runtimes that do not implement a Scripting Runtime.
          The [[!WOT-ARCHITECTURE]] document provides generic security guidelines
          for this group.
        </li>
        <li>
          Implementors of the WoT Scripting API in a WoT Scripting Runtime. This is the main scope and is covered in the
          <a href="#sec-security-consideration-runtime">
          Scripting Runtime Security and Privacy Risks</a> sub-section that
          contains normative text regarding security.
        </li>
        <li>
          WoT script developers, covered in the
          <a href="#sec-security-consideration-script">
          Script Security and Privacy Risks</a> sub-section that contains
          informative recommendations concerning security.
        </li>
      </ul>
    </div>

    <section id="sec-security-consideration-runtime">
      <h3>Scripting Runtime Security and Privacy Risks</h3>
      <p>
        This section is normative and contains specific risks relevant for the WoT Scripting Runtime.
      </p>

      <section id="sec-security-consideration-input">
        <h3>Corrupted Input Security and Privacy Risk</h3>
        <p>
          A typical way to compromise any process is to send it a corrupted input
          via one of the exposed interfaces. This can be done to a script instance
          using WoT interface it exposes.
        </p>
        <dl><dt>Mitigation:</dt><dd>
          Implementors of this API SHOULD perform validation on all script inputs. In addition to input validation, <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a> should be used to verify that the input processing is done correctly. There are many tools and techniques in existence to do such validation. More details can be found in [[!WOT-SECURITY]].
        </dd></dl>
      </section>

      <section id="sec-security-consideration-device-direct-access">
        <h3>Physical Device Direct Access Security and Privacy Risk</h3>
        <p>
          In case a script is compromised or misbehaving, the underlying physical device (and potentially surrounded environment) can be damaged if a script can use directly exposed native device interfaces. If such interfaces lack safety checks on their inputs, they might bring the underlying physical device (or environment) to an unsafe state (i.e. device overheats and explodes).
        </p>
        <dl><dt>Mitigation:</dt><dd>
          The WoT Scripting Runtime SHOULD avoid directly exposing the native device interfaces to the script developers. Instead, a WoT Scripting Runtime should provide a hardware abstraction layer for accessing the native device interfaces. Such hardware abstraction layer should refuse to execute commands that might put the device (or environment) to an unsafe state.
          Additionally, in order to reduce the damage to a physical WoT device in cases a script gets compromised, it is important to minimize the number of interfaces that are exposed or accessible to a particular script based on its functionality.
        </dd></dl>
      </section>

      <section id="sec-security-consideration-update-provisioning">
        <h3>Provisioning and Update Security Risk</h3>
        <p>
          If the WoT Scripting Runtime supports post-manufacturing provisioning
          or updates of scripts, WoT Scripting Runtime or any related data
          (including security credentials), it can be a major attack vector.
          An attacker can try to modify any above described element
          during the update or provisioning process or simply
          provision attacker's code and data directly.
        </p>
        <dl><dt>Mitigation:</dt><dd>
            Post-manufacturing provisioning or update of scripts,
            WoT Scripting Runtime or any related data should be done in a secure fashion.
            A set of recommendations for secure update and post-manufacturing
            provisioning can be found in [[!WOT-SECURITY]].
        </dd></dl>
      </section>

      <section id="sec-security-consideration-credentials-storage">
        <h3>Security Credentials Storage Security and Privacy Risk</h3>
        <p>
          Typically the WoT Scripting Runtime needs to store the security credentials that are provisioned to a WoT device to operate in WoT network. If an attacker can compromise the confidentiality or integrity of these credentials, then it can obtain access to the WoT assets, impersonate WoT things or devices or create Denial-Of-Service (DoS) attacks.
        </p>
        <dl><dt>Mitigation:</dt><dd>
          The WoT Scripting Runtime should securely store the provisioned security credentials, guaranteeing their integrity and confidentiality.
          In case there are more than one tenant on a single WoT-enabled device, a WoT Scripting Runtime should guarantee isolation of each tenant provisioned security credentials.
          Additionally, in order to minimize a risk that provisioned security credentials get compromised, the WoT Scripting Runtime should not expose any API for scripts to query the provisioned security credentials.
        </dd></dl>
      </section>
    </section>

    <section id="sec-security-consideration-script" class="informative">
      <h3>Script Security and Privacy Risks</h3>
      <p>
        This section describes specific risks relevant for script developers.
      </p>

      <section id="sec-security-consideration-script-input">
        <h3>Corrupted Script Input Security and Privacy Risk</h3>
        <p>
          A script instance may receive data formats defined by the TD, or data formats defined by the applications. While the WoT Scripting Runtime SHOULD perform validation on all input fields defined by the TD, scripts may be still exploited by input data.
        </p>
        <dl><dt>Mitigation:</dt><dd>
          Script developers should perform validation on all application defined script inputs. In addition to input validation, <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a> could be used to verify that the input processing is done correctly. There are many tools and techniques in existence to do such validation. More details can be found in [[!WOT-SECURITY]].
        </dd></dl>
      </section>

      <section id="sec-security-consideration-script-processing">
        <h3>Denial of Service (DoS) Security Risk</h3>
        <p>
          If a script performs heavy functional processing on received requests before the request is authenticated, it presents a great risk for Denial-of-Service (DoS) attacks.
        </p>
        <dl><dt>Mitigation:</dt><dd>
          Scripts should avoid heavy functional processing without prior successful
          authentication of requestor. The set of recommended authentication mechanisms
          can be found in [[!WOT-SECURITY]].
        </dd></dl>
      </section>

    </section>
  </section>

  <section class="appendix">
    <h2>API design rationale</h2>
    <p>
      API rationale usually belongs to a separate document, but in the WoT case
      the complexity of the context justifies including basic rationale here.
    </p>
    <section> <h3>Approaches to WoT application development</h3>
      <p>
        The WoT Interest Group and Working Group have explored different
        approaches to application development for WoT that have been all
        implemented and tested.
      </p>
      <section> <h3>No Scripting API</h3>
        <p>
          It is possible to develop WoT applications that only use the
          <a>WoT network interface</a>, typically exposed by a WoT gateway that
          presents a RESTful API towards clients and implements IoT protocol
          plugins that communicate with supported IoT deployments. One such
          implementation is the
          <a href="https://iot.mozilla.org/">Mozilla WebThings</a> platform.
        </p>
      </section>
      <section> <h3>Simple Scripting API</h3>
        <p>
          WoT <a>Thing</a>s show good synergy with software objects, so a
          <a>Thing</a> can be represented as a software object, with <a>Properties</a> represented as object properties, <a>Action</a>s as methods, and
          <a>Event</a>s as events. In addition, metadata is stored in special
          properties. Consuming and exposing is done with factory methods that
          produce a software object that directly represents a remote <a>Thing</a>
          and its interactions. One such implementation is the
          <a href="https://github.com/draggett/arena-webhub">Arena Web Hub</a>
          project.
        </p>
        <p>
          In the next example, a <a>Thing</a> that represents interactions with
          a lock would look like the following: the |status| property
          and the <code>open()</code> method are directly exposed on the object.
        </p>
        <pre class="example" title="Open a lock with a simple API">
          let lock = await WoT.consume('https://td.my.com/lock-00123');
          console.log(lock.status);
          lock.open('withThisKey');
        </pre>
      </section>
      <section> <h3>This API, aligned with the [[[WOT-TD]]] specification</h3>
        <p>
          Since the direct mapping of <a>Thing</a>s to software objects have had
          some challenges, this specification takes another approach that
          exposes software objects to represent the <a>Thing</a> metadata as
          data property and the WoT interactions as methods. One implementation
          is <a href="https://github.com/eclipse-thingweb/node-wot">node-wot</a>
          in the <a href="https://www.thingweb.io/">Eclipse ThingWeb</a> project,
          which is the current reference implementation of the API specified in
          this document.
        </p>
        <p>
          The same example now would look like the following: the
          |status| property and the <code>open()</code> method are
          represented indirectly.
        </p>
        <pre class="example" title="Open a lock">
          const lockTd = await WoT.requestThingDescription('https://td.my.com/lock-00123');
          const lock = WoT.consume(lockTd);
          console.log(lock.readProperty('status'));
          lock.invokeAction('open', 'withThisKey');
        </pre>
      </section>
      <p>
        In conclusion, the WoT WG decided to explore the third option that
        closely follows the [[[WOT-TD]]] specification. Based on this, a simple
        API can also be implemented.
        Since Scripting is an optional module in WoT, this leaves room for
        applications that only use the <a>WoT network interface</a>.
        Therefore all three approaches above are supported by the [[[WOT-TD]]] specification.
      </p>
      <p>
        Moreover, the <a>WoT network interface</a> can be implemented in many languages
        and runtimes. Consider this API an example for what needs to be taken
        into consideration when designing a Scripting API for WoT.
      </p>
    </section>
    <section>
      <h4>Requesting and validating a TD</h4>
      <p>
        The current version of this specification defines a new
        `requestThingDescription` method that simplifies the process of
        retrieving and validating a Thing Description.
        However, it only covers simple use cases that do not require additional
        parameters or special HTTP headers for the retrieval.
      </p>
      <p>
        More sophisticated use cases need to be covered by external methods, such
        as the <a data-cite="fetch#fetch-api">Fetch API</a> or an
        HTTP client library, which offer already standardized options on
        specifying fetch details.
        In these cases, the user is required to perform validation manually as
        described by the [[[WOT-TD]]] specification.
      </p>
      <p class="ednote" title="Extending the `requestThingDescription()` method">
        In the future, `requestThingDescription()` might be extended with an
        `options` argument, including frequently used `fetch` options.
        Please
        <a href="https://github.com/w3c/wot-scripting-api/issues/new">
          open an issue
        </a> to request support for options.
    </p>
    </section>
    <section> <h4>Observers</h4>
      <p>
        Earlier drafts used the
        <a href="https://github.com/tc39/proposal-observable">Observer</a>
        construct, but since it has not become standard, a new design was needed
        that was light enough for embedded implementations. Therefore observing
        <a>Property</a> changes and handling WoT <a>Event</a>s is done with
        callback registrations.
      </p>
    </section>
    <section> <h4>Using Events</h4>
      <div>
        This API ended up not using software events at all, for the following
        reasons:
        <ul>
          <li>
            Subscription to WoT <a>Event</a>s may be different from handling software events (subscription might need parameters, might involve security tokens etc).
          </li>
          <li>
            Most implementations are for Node.js and browser implementations will likely be libraries (because possible dependency management issues in native implementations), using Events has been challenging.
          </li>
          <li>
            Observing <a>Property</a> changes and handling WoT <a>Event</a>s is done with the solution above.
          </li>
        </ul>
      </div>
    </section>
    <section> <h4>Polymorphic functions</h4>
      <p>
        The reason to use function names like <code>readProperty()</code>, <code>readMultipleProperties()</code> etc. instead of a generic polymorphic <code>read()</code> function is that the current names map exactly to the <code>"op"</code> vocabulary from the <a data-cite="WOT-TD#form">Form</a> definition in the [[[WOT-TD]]] specification.
      </p>
    </section>
  </section>

  <section class="appendix" id="Changes"><h2>Changes</h2>
    <div>
      The following is a list of major changes to the document. Major versions of this specification are the following:
      <ul>
        <li>
          First Public Working Draft <a href="https://www.w3.org/TR/2017/WD-wot-scripting-api-20170914/">September 2017</a>.
        </li>
        <li>
          Working Draft <a href="https://www.w3.org/TR/2018/WD-wot-scripting-api-20180405/">April 2018</a>.
        </li>
        <li>
          Working Draft <a href="https://www.w3.org/TR/2018/WD-wot-scripting-api-20181129/">November 2018</a>.
        </li>
        <li>
          Working draft <a href="https://www.w3.org/TR/2019/WD-wot-scripting-api-20191028/">October 2019</a>.
        </li>
        <li>
          This version, introducing the following major changes:
          <ul>
            <li>
              Added support for `formIndex`, `InteractionData` including streams.
            </li>
            <li>
              Cleaned up the specification prose, aligned terminology and
              used modern ReSpec.
            </li>
            <li>
              Improved algorithm descriptions, included illustrative figures.
            </li>
          </ul>
        </li>
      </ul>
    </div>
    <p>
      For a complete list of changes, see the <a href="https://github.com/w3c/wot-scripting-api/commits/main">github change log</a>. You can also view the <a href="https://github.com/w3c/wot-scripting-api/issues?page=1&amp;state=closed">recently closed issues</a>.
    </p>
  </section>

  <section class="appendix" id="idl-index"> <h3>Full Web IDL</h3>
    <!-- ReSpec will gather all Web IDL code here. -->
  </section>

  <section class="appendix"> <h2>Acknowledgements</h2>
    <p>
      Special thanks to former editor Johannes Hund (until August 2017, when at Siemens AG) and Kazuaki Nimura (until December 2018) for developing this specification. Also, the editors would like to thank Dave Raggett, Matthias Kovatsch, Michael Koster, Elena Reshetova, Michael McCool as well as the other WoT WG members for their comments, contributions and guidance.
    </p>
  </section>

  </body>
</html>
